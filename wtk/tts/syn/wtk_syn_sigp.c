#include <math.h>
#include "wtk_syn_sigp.h" 

static  float _data[] = { 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,
        1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,
        1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,
        1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,
        1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 0.999999, 0.999999,
        0.999999, 0.999999, 0.999999, 0.999999, 0.999998, 0.999998, 0.999997, 0.999997, 0.999996, 0.999994, 0.999993,
        0.999991, 0.999987, 0.999981, 0.999971, 0.999954, 0.999930, 0.999902, 0.999878, 0.999869, 0.999876, 0.999890,
        0.999898, 0.999891, 0.999869, 0.999840, 0.999808, 0.999766, 0.999699, 0.999591, 0.999425, 0.999208, 0.999028,
        0.999018, 0.999208, 0.999480, 0.999706, 0.999845, 0.999912, 0.999928, 0.999889, 0.999734, 0.999336, 0.998532,
        0.997254, 0.995695, 0.994359, 0.993573, 0.992697, 0.990204, 0.984718, 0.976845, 0.970201, 0.968603, 0.972449,
        0.979077, 0.985659, 0.990812, 0.994239, 0.996029, 0.996284, 0.994711, 0.990644, 0.985001, 0.981774, 0.983304,
        0.986596, 0.988141, 0.987283, 0.985097, 0.983430, 0.983982, 0.985777, 0.984285, 0.972274, 0.938442, 0.873651,
        0.780698, 0.669798, 0.548641, 0.421403, 0.299594, 0.217122, 0.219814, 0.322718, 0.482709, 0.625968, 0.699407,
        0.680764, 0.559764, 0.353193, 0.121144, -0.089863, -0.285481, -0.479019, -0.652798, -0.780178, -0.857049,
        -0.897487, -0.916841, -0.925623, -0.929896, -0.930732, -0.925207, -0.913043, -0.903326, -0.909057, -0.931628,
        -0.959312, -0.981046, -0.993514, -0.998691, -1.000000, -0.997556, -0.979486, -0.914540, -0.779543, -0.608235,
        -0.468932, -0.389531, -0.338718, -0.277964, -0.218573, -0.218085, -0.316278, -0.485345, -0.651313, -0.762347,
        -0.817976, -0.843824, -0.864157, -0.888075, -0.909906, -0.921785, -0.922559, -0.916621, -0.907277, -0.891596,
        -0.862779, -0.812703, -0.728252, -0.593040, -0.406772, -0.200080, -0.013810, 0.126353, 0.206873, 0.221573,
        0.179548, 0.106190, 0.030958, -0.016675, -0.000758, 0.103969, 0.271004, 0.423904, 0.504561, 0.504350, 0.430721,
        0.290721, 0.116273, -0.028778, -0.096358, -0.084823, -0.016427, 0.091421, 0.227079, 0.368364, 0.481708,
        0.544672, 0.565953, 0.585728, 0.652758, 0.782023, 0.926650, 0.999590, 0.939045, 0.761620, 0.541489, 0.340335,
        0.175250, 0.035959, -0.098156, -0.252621, -0.438604, -0.631326, -0.789968, -0.896991, -0.958843, -0.986834,
        -0.993911, -0.988401, -0.962102, -0.902861, -0.816717, -0.733974, -0.698690, -0.741778, -0.846449, -0.946659,
        -0.992905, -1.000000, -0.999753, -0.999915, -0.997910, -0.995034, -0.997057, -0.999080, -0.968236, -0.883614,
        -0.788669, -0.747960, -0.779524, -0.854004, -0.929246, -0.977559, -0.995893, -0.998708, -0.994477, -0.972999,
        -0.919014, -0.819809, -0.667804, -0.479190, -0.294375, -0.139046, -0.003039, 0.138825, 0.307385, 0.513590,
        0.741215, 0.928646, 0.999999, 0.935989, 0.796788, 0.669661, 0.602688, 0.582099, 0.560031, 0.496713, 0.383240,
        0.241631, 0.105303, -0.003434, -0.072764, -0.085148, -0.018312, 0.125935, 0.299364, 0.438290, 0.511074,
        0.510804, 0.429986, 0.277006, 0.109726, 0.004612, -0.011696, 0.035572, 0.110444, 0.183448, 0.225156, 0.210203,
        0.129481, -0.010888, -0.197428, -0.404482, -0.591170, -0.726778, -0.811543, -0.861847, -0.890823, -0.906613,
        -0.916036, -0.922037, -0.921300, -0.909425, -0.887582, -0.863658, -0.843331, -0.817488, -0.761839, -0.650762,
        -0.484757, -0.315689, -0.217524, -0.218054, -0.277492, -0.338290, -0.389143, -0.468589, -0.607949, -0.779334,
        -0.914415, -0.979428, -0.997537, -1.000000, -0.998702, -0.993537, -0.981084, -0.959362, -0.931688, -0.909121,
        -0.903387, -0.913096, -0.925253, -0.930773, -0.929934, -0.925659, -0.916876, -0.897523, -0.857088, -0.780222,
        -0.652846, -0.479071, -0.285534, -0.089913, 0.121097, 0.353152, 0.559731, 0.680737, 0.699382, 0.625944,
        0.482684, 0.322692, 0.219790, 0.217100, 0.299573, 0.421385, 0.548626, 0.669786, 0.780688, 0.873644, 0.938438,
        0.972271, 0.984283, 0.985775, 0.983980, 0.983428, 0.985096, 0.987282, 0.988140, 0.986595, 0.983303, 0.981773,
        0.985000, 0.990643, 0.994711, 0.996284, 0.996028, 0.994239, 0.990812, 0.985659, 0.979076, 0.972449, 0.968603,
        0.970201, 0.976845, 0.984718, 0.990204, 0.992697, 0.993572, 0.994359, 0.995695, 0.997254, 0.998532, 0.999335,
        0.999734, 0.999889, 0.999928, 0.999912, 0.999845, 0.999706, 0.999480, 0.999208, 0.999018, 0.999028, 0.999208,
        0.999425, 0.999591, 0.999699, 0.999766, 0.999808, 0.999840, 0.999869, 0.999891, 0.999898, 0.999890, 0.999876,
        0.999869, 0.999878, 0.999902, 0.999930, 0.999954, 0.999971, 0.999981, 0.999987, 0.999991, 0.999993, 0.999994,
        0.999996, 0.999997, 0.999997, 0.999998, 0.999998, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999,
        1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,
        1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,
        1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,
        1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000,
        1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000 };

static  float _imag[] = { -0.000000, 0.000001, 0.000000, -0.000000, -0.000001, -0.000001, -0.000001, 0.000000,
        0.000001, 0.000002, 0.000001, 0.000001, 0.000005, 0.000013, 0.000024, 0.000037, 0.000048, 0.000054, 0.000055,
        0.000052, 0.000044, 0.000034, 0.000023, 0.000011, -0.000005, -0.000033, -0.000075, -0.000128, -0.000186,
        -0.000246, -0.000305, -0.000357, -0.000392, -0.000411, -0.000420, -0.000424, -0.000421, -0.000414, -0.000404,
        -0.000384, -0.000344, -0.000302, -0.000295, -0.000337, -0.000400, -0.000448, -0.000490, -0.000571, -0.000708,
        -0.000876, -0.001034, -0.001142, -0.001192, -0.001229, -0.001334, -0.001547, -0.001822, -0.002090, -0.002343,
        -0.002626, -0.002966, -0.003353, -0.003785, -0.004307, -0.005025, -0.006087, -0.007612, -0.009591, -0.011835,
        -0.013993, -0.015596, -0.016206, -0.015760, -0.014817, -0.014291, -0.014794, -0.016199, -0.017902, -0.019602,
        -0.021642, -0.024533, -0.028590, -0.033917, -0.039796, -0.044083, -0.044312, -0.039804, -0.032246, -0.024238,
        -0.017616, -0.013256, -0.011965, -0.014911, -0.023048, -0.036449, -0.054157, -0.074058, -0.092694, -0.106067,
        -0.113197, -0.120633, -0.139628, -0.174155, -0.213946, -0.242301, -0.248612, -0.233114, -0.203491, -0.168749,
        -0.135247, -0.107187, -0.089033, -0.086125, -0.102711, -0.136475, -0.172549, -0.190053, -0.181971, -0.163179,
        -0.153547, -0.158970, -0.172000, -0.181290, -0.178269, -0.168059, -0.176587, -0.233845, -0.345437, -0.486554,
        -0.624909, -0.742543, -0.836058, -0.906873, -0.954067, -0.976144, -0.975542, -0.946495, -0.875781, -0.779848,
        -0.714724, -0.732503, -0.828652, -0.935551, -0.992635, -0.995954, -0.958384, -0.877804, -0.757532, -0.625557,
        -0.515235, -0.441040, -0.399253, -0.378447, -0.367823, -0.365702, -0.379463, -0.407863, -0.428954, -0.416671,
        -0.363413, -0.282349, -0.193773, -0.113714, -0.051157, -0.000273, 0.069872, 0.201513, 0.404496, 0.626349,
        0.793757, 0.883234, 0.921013, 0.940888, 0.960591, 0.975821, 0.975930, 0.948667, 0.874323, 0.758809, 0.647168,
        0.575252, 0.536621, 0.503223, 0.459700, 0.414816, 0.387700, 0.385856, 0.399758, 0.420533, 0.452831, 0.505581,
        0.582678, 0.685310, 0.805173, 0.913530, 0.979780, 0.999905, 0.991985, 0.978368, 0.975144, 0.983749, 0.994346,
        0.999521, 0.999861, 1.000000, 0.994581, 0.962578, 0.905707, 0.863376, 0.863499, 0.902485, 0.956808, 0.993217,
        0.999586, 0.995347, 0.996396, 0.999865, 0.995812, 0.973876, 0.929682, 0.876332, 0.838649, 0.824438, 0.810508,
        0.757566, 0.623249, 0.375925, 0.028634, -0.343795, -0.648024, -0.840708, -0.940304, -0.984524, -0.999353,
        -0.995171, -0.967565, -0.898681, -0.775518, -0.613149, -0.442048, -0.283938, -0.161734, -0.110187, -0.151867,
        -0.272691, -0.429933, -0.577038, -0.679178, -0.715425, -0.670645, -0.532470, -0.322238, -0.118907, -0.000247,
        0.022242, -0.013036, -0.064613, -0.099537, -0.076665, 0.042886, 0.250039, 0.468216, 0.614818, 0.663744,
        0.626373, 0.520266, 0.369461, 0.210663, 0.090543, 0.050819, 0.104956, 0.230811, 0.394225, 0.572638, 0.744337,
        0.877711, 0.955690, 0.990286, 0.999995, 0.990317, 0.951585, 0.858036, 0.671268, 0.370967, -0.001302, -0.352030,
        -0.604259, -0.742667, -0.797977, -0.813118, -0.828472, -0.867915, -0.923649, -0.970368, -0.994440, -0.999994,
        -0.997349, -0.996368, -0.999832, -0.992039, -0.954139, -0.898834, -0.859537, -0.859697, -0.902836, -0.960868,
        -0.993962, -0.999989, -0.999932, -0.999367, -0.993882, -0.983029, -0.974323, -0.977658, -0.991582, -0.999941,
        -0.980317, -0.914546, -0.806547, -0.686873, -0.584293, -0.507169, -0.454350, -0.421963, -0.401096, -0.387102,
        -0.388853, -0.415868, -0.460650, -0.504079, -0.537394, -0.575945, -0.647766, -0.759281, -0.874649, -0.948863,
        -0.976055, -0.975937, -0.960728, -0.941042, -0.921177, -0.883417, -0.793976, -0.626609, -0.404778, -0.201792,
        -0.070135, 0.000030, 0.050932, 0.113507, 0.193584, 0.282178, 0.363260, 0.416533, 0.428827, 0.407744, 0.379352,
        0.365598, 0.367727, 0.378359, 0.399173, 0.440967, 0.515170, 0.625503, 0.757490, 0.877776, 0.958369, 0.995950,
        0.992641, 0.935566, 0.828674, 0.732528, 0.714748, 0.779868, 0.875795, 0.946504, 0.975547, 0.976149, 0.954073,
        0.906882, 0.836068, 0.742554, 0.624921, 0.486566, 0.345449, 0.233857, 0.176598, 0.168070, 0.178278, 0.181298,
        0.172008, 0.158978, 0.153553, 0.163186, 0.181977, 0.190058, 0.172554, 0.136479, 0.102715, 0.086129, 0.089036,
        0.107190, 0.135250, 0.168752, 0.203493, 0.233116, 0.248614, 0.242302, 0.213948, 0.174157, 0.139629, 0.120634,
        0.113198, 0.106068, 0.092695, 0.074059, 0.054157, 0.036450, 0.023048, 0.014911, 0.011965, 0.013257, 0.017617,
        0.024238, 0.032247, 0.039804, 0.044312, 0.044082, 0.039796, 0.033917, 0.028590, 0.024533, 0.021642, 0.019602,
        0.017901, 0.016199, 0.014794, 0.014290, 0.014817, 0.015759, 0.016206, 0.015596, 0.013992, 0.011835, 0.009591,
        0.007611, 0.006086, 0.005024, 0.004306, 0.003785, 0.003352, 0.002965, 0.002625, 0.002343, 0.002090, 0.001822,
        0.001547, 0.001334, 0.001228, 0.001191, 0.001141, 0.001033, 0.000876, 0.000707, 0.000570, 0.000490, 0.000447,
        0.000399, 0.000336, 0.000294, 0.000302, 0.000344, 0.000383, 0.000404, 0.000414, 0.000421, 0.000423, 0.000419,
        0.000410, 0.000391, 0.000356, 0.000305, 0.000245, 0.000185, 0.000127, 0.000074, 0.000032, 0.000005, -0.000012,
        -0.000024, -0.000035, -0.000045, -0.000052, -0.000056, -0.000054, -0.000048, -0.000038, -0.000025, -0.000013,
        -0.000006, -0.000002, -0.000001, -0.000002, -0.000002, -0.000001, 0.000000, 0.000001, 0.000000, -0.000000,
        -0.000001, -0.000001, -0.000001 };

 float data[] = { 1.000000, -0.999925, 0.999699, -0.999322, 0.998795, -0.998118, 0.997290, -0.996313, 0.995185,
        -0.993907, 0.992480, -0.990903, 0.989177, -0.987301, 0.985278, -0.983105, 0.980785, -0.978317, 0.975702,
        -0.972940, 0.970031, -0.966976, 0.963776, -0.960431, 0.956940, -0.953306, 0.949528, -0.945607, 0.941544,
        -0.937339, 0.932993, -0.928506, 0.923880, -0.919114, 0.914210, -0.909168, 0.903989, -0.898674, 0.893224,
        -0.887640, 0.881921, -0.876070, 0.870087, -0.863973, 0.857729, -0.851355, 0.844854, -0.838225, 0.831470,
        -0.824589, 0.817585, -0.810457, 0.803208, -0.795837, 0.788346, -0.780737, 0.773010, -0.765167, 0.757209,
        -0.749136, 0.740951, -0.732654, 0.724247, -0.715731, 0.707107, -0.698376, 0.689541, -0.680601, 0.671559,
        -0.662416, 0.653173, -0.643832, 0.634393, -0.624859, 0.615232, -0.605511, 0.595699, -0.585798, 0.575808,
        -0.565732, 0.555570, -0.545325, 0.534998, -0.524590, 0.514103, -0.503538, 0.492898, -0.482184, 0.471397,
        -0.460539, 0.449611, -0.438616, 0.427555, -0.416430, 0.405241, -0.393992, 0.382683, -0.371317, 0.359895,
        -0.348419, 0.336890, -0.325310, 0.313682, -0.302006, 0.290285, -0.278520, 0.266713, -0.254866, 0.242980,
        -0.231058, 0.219101, -0.207111, 0.195090, -0.183040, 0.170962, -0.158858, 0.146730, -0.134581, 0.122411,
        -0.110222, 0.098017, -0.085797, 0.073565, -0.061321, 0.049068, -0.036807, 0.024541, -0.012272, -0.000000,
        0.012272, -0.024541, 0.036807, -0.049068, 0.061321, -0.073565, 0.085797, -0.098017, 0.110222, -0.122411,
        0.134581, -0.146730, 0.158858, -0.170962, 0.183040, -0.195090, 0.207111, -0.219101, 0.231058, -0.242980,
        0.254866, -0.266713, 0.278520, -0.290285, 0.302006, -0.313682, 0.325310, -0.336890, 0.348419, -0.359895,
        0.371317, -0.382683, 0.393992, -0.405241, 0.416430, -0.427555, 0.438616, -0.449611, 0.460539, -0.471397,
        0.482184, -0.492898, 0.503538, -0.514103, 0.524590, -0.534998, 0.545325, -0.555570, 0.565732, -0.575808,
        0.585798, -0.595699, 0.605511, -0.615232, 0.624859, -0.634393, 0.643832, -0.653173, 0.662416, -0.671559,
        0.680601, -0.689541, 0.698376, -0.707107, 0.715731, -0.724247, 0.732654, -0.740951, 0.749136, -0.757209,
        0.765167, -0.773010, 0.780737, -0.788346, 0.795837, -0.803208, 0.810457, -0.817585, 0.824589, -0.831470,
        0.838225, -0.844854, 0.851355, -0.857729, 0.863973, -0.870087, 0.876070, -0.881921, 0.887640, -0.893224,
        0.898674, -0.903989, 0.909168, -0.914210, 0.919114, -0.923880, 0.928506, -0.932993, 0.937339, -0.941544,
        0.945607, -0.949528, 0.953306, -0.956940, 0.960431, -0.963776, 0.966976, -0.970031, 0.972940, -0.975702,
        0.978317, -0.980785, 0.983105, -0.985278, 0.987301, -0.989177, 0.990903, -0.992480, 0.993907, -0.995185,
        0.996313, -0.997290, 0.998118, -0.998795, 0.999322, -0.999699, 0.999925, -1.000000, 0.999925, -0.999699,
        0.999322, -0.998795, 0.998118, -0.997290, 0.996313, -0.995185, 0.993907, -0.992480, 0.990903, -0.989177,
        0.987301, -0.985278, 0.983105, -0.980785, 0.978317, -0.975702, 0.972940, -0.970031, 0.966976, -0.963776,
        0.960431, -0.956940, 0.953306, -0.949528, 0.945607, -0.941544, 0.937339, -0.932993, 0.928506, -0.923880,
        0.919114, -0.914210, 0.909168, -0.903989, 0.898674, -0.893224, 0.887640, -0.881921, 0.876070, -0.870087,
        0.863973, -0.857729, 0.851355, -0.844854, 0.838225, -0.831470, 0.824589, -0.817585, 0.810457, -0.803208,
        0.795837, -0.788346, 0.780737, -0.773010, 0.765167, -0.757209, 0.749136, -0.740951, 0.732654, -0.724247,
        0.715731, -0.707107, 0.698376, -0.689541, 0.680601, -0.671559, 0.662416, -0.653173, 0.643832, -0.634393,
        0.624859, -0.615232, 0.605511, -0.595699, 0.585798, -0.575808, 0.565732, -0.555570, 0.545325, -0.534998,
        0.524590, -0.514103, 0.503538, -0.492898, 0.482184, -0.471397, 0.460539, -0.449611, 0.438616, -0.427555,
        0.416430, -0.405241, 0.393992, -0.382683, 0.371317, -0.359895, 0.348419, -0.336890, 0.325310, -0.313682,
        0.302006, -0.290285, 0.278520, -0.266713, 0.254866, -0.242980, 0.231058, -0.219101, 0.207111, -0.195090,
        0.183040, -0.170962, 0.158858, -0.146730, 0.134581, -0.122411, 0.110222, -0.098017, 0.085797, -0.073565,
        0.061321, -0.049068, 0.036807, -0.024541, 0.012272, 0.000000, -0.012272, 0.024541, -0.036807, 0.049068,
        -0.061321, 0.073565, -0.085797, 0.098017, -0.110222, 0.122411, -0.134581, 0.146730, -0.158858, 0.170962,
        -0.183040, 0.195090, -0.207111, 0.219101, -0.231058, 0.242980, -0.254866, 0.266713, -0.278520, 0.290285,
        -0.302006, 0.313682, -0.325310, 0.336890, -0.348419, 0.359895, -0.371317, 0.382683, -0.393992, 0.405241,
        -0.416430, 0.427555, -0.438616, 0.449611, -0.460539, 0.471397, -0.482184, 0.492898, -0.503538, 0.514103,
        -0.524590, 0.534998, -0.545325, 0.555570, -0.565732, 0.575808, -0.585798, 0.595699, -0.605511, 0.615232,
        -0.624859, 0.634393, -0.643832, 0.653173, -0.662416, 0.671559, -0.680601, 0.689541, -0.698376, 0.707107,
        -0.715731, 0.724247, -0.732654, 0.740951, -0.749136, 0.757209, -0.765167, 0.773010, -0.780737, 0.788346,
        -0.795837, 0.803208, -0.810457, 0.817585, -0.824589, 0.831470, -0.838225, 0.844854, -0.851355, 0.857729,
        -0.863973, 0.870087, -0.876070, 0.881921, -0.887640, 0.893224, -0.898674, 0.903989, -0.909168, 0.914210,
        -0.919114, 0.923880, -0.928506, 0.932993, -0.937339, 0.941544, -0.945607, 0.949528, -0.953306, 0.956940,
        -0.960431, 0.963776, -0.966976, 0.970031, -0.972940, 0.975702, -0.978317, 0.980785, -0.983105, 0.985278,
        -0.987301, 0.989177, -0.990903, 0.992480, -0.993907, 0.995185, -0.996313, 0.997290, -0.998118, 0.998795,
        -0.999322, 0.999699, -0.999925 };
float  imag[] = { 0.000000, -0.012272, 0.024541, -0.036807, 0.049068, -0.061321, 0.073565, -0.085797, 0.098017,
        -0.110222, 0.122411, -0.134581, 0.146730, -0.158858, 0.170962, -0.183040, 0.195090, -0.207111, 0.219101,
        -0.231058, 0.242980, -0.254866, 0.266713, -0.278520, 0.290285, -0.302006, 0.313682, -0.325310, 0.336890,
        -0.348419, 0.359895, -0.371317, 0.382683, -0.393992, 0.405241, -0.416430, 0.427555, -0.438616, 0.449611,
        -0.460539, 0.471397, -0.482184, 0.492898, -0.503538, 0.514103, -0.524590, 0.534998, -0.545325, 0.555570,
        -0.565732, 0.575808, -0.585798, 0.595699, -0.605511, 0.615232, -0.624859, 0.634393, -0.643832, 0.653173,
        -0.662416, 0.671559, -0.680601, 0.689541, -0.698376, 0.707107, -0.715731, 0.724247, -0.732654, 0.740951,
        -0.749136, 0.757209, -0.765167, 0.773010, -0.780737, 0.788346, -0.795837, 0.803208, -0.810457, 0.817585,
        -0.824589, 0.831470, -0.838225, 0.844854, -0.851355, 0.857729, -0.863973, 0.870087, -0.876070, 0.881921,
        -0.887640, 0.893224, -0.898674, 0.903989, -0.909168, 0.914210, -0.919114, 0.923880, -0.928506, 0.932993,
        -0.937339, 0.941544, -0.945607, 0.949528, -0.953306, 0.956940, -0.960431, 0.963776, -0.966976, 0.970031,
        -0.972940, 0.975702, -0.978317, 0.980785, -0.983105, 0.985278, -0.987301, 0.989177, -0.990903, 0.992480,
        -0.993907, 0.995185, -0.996313, 0.997290, -0.998118, 0.998795, -0.999322, 0.999699, -0.999925, 1.000000,
        -0.999925, 0.999699, -0.999322, 0.998795, -0.998118, 0.997290, -0.996313, 0.995185, -0.993907, 0.992480,
        -0.990903, 0.989177, -0.987301, 0.985278, -0.983105, 0.980785, -0.978317, 0.975702, -0.972940, 0.970031,
        -0.966976, 0.963776, -0.960431, 0.956940, -0.953306, 0.949528, -0.945607, 0.941544, -0.937339, 0.932993,
        -0.928506, 0.923880, -0.919114, 0.914210, -0.909168, 0.903989, -0.898674, 0.893224, -0.887640, 0.881921,
        -0.876070, 0.870087, -0.863973, 0.857729, -0.851355, 0.844854, -0.838225, 0.831470, -0.824589, 0.817585,
        -0.810457, 0.803208, -0.795837, 0.788346, -0.780737, 0.773010, -0.765167, 0.757209, -0.749136, 0.740951,
        -0.732654, 0.724247, -0.715731, 0.707107, -0.698376, 0.689541, -0.680601, 0.671559, -0.662416, 0.653173,
        -0.643832, 0.634393, -0.624859, 0.615232, -0.605511, 0.595699, -0.585798, 0.575808, -0.565732, 0.555570,
        -0.545325, 0.534998, -0.524590, 0.514103, -0.503538, 0.492898, -0.482184, 0.471397, -0.460539, 0.449611,
        -0.438616, 0.427555, -0.416430, 0.405241, -0.393992, 0.382683, -0.371317, 0.359895, -0.348419, 0.336890,
        -0.325310, 0.313682, -0.302006, 0.290285, -0.278520, 0.266713, -0.254866, 0.242980, -0.231058, 0.219101,
        -0.207111, 0.195090, -0.183040, 0.170962, -0.158858, 0.146730, -0.134581, 0.122411, -0.110222, 0.098017,
        -0.085797, 0.073565, -0.061321, 0.049068, -0.036807, 0.024541, -0.012272, 0.000000, 0.012272, -0.024541,
        0.036807, -0.049068, 0.061321, -0.073565, 0.085797, -0.098017, 0.110222, -0.122411, 0.134581, -0.146730,
        0.158858, -0.170962, 0.183040, -0.195090, 0.207111, -0.219101, 0.231058, -0.242980, 0.254866, -0.266713,
        0.278520, -0.290285, 0.302006, -0.313682, 0.325310, -0.336890, 0.348419, -0.359895, 0.371317, -0.382683,
        0.393992, -0.405241, 0.416430, -0.427555, 0.438616, -0.449611, 0.460539, -0.471397, 0.482184, -0.492898,
        0.503538, -0.514103, 0.524590, -0.534998, 0.545325, -0.555570, 0.565732, -0.575808, 0.585798, -0.595699,
        0.605511, -0.615232, 0.624859, -0.634393, 0.643832, -0.653173, 0.662416, -0.671559, 0.680601, -0.689541,
        0.698376, -0.707107, 0.715731, -0.724247, 0.732654, -0.740951, 0.749136, -0.757209, 0.765167, -0.773010,
        0.780737, -0.788346, 0.795837, -0.803208, 0.810457, -0.817585, 0.824589, -0.831470, 0.838225, -0.844854,
        0.851355, -0.857729, 0.863973, -0.870087, 0.876070, -0.881921, 0.887640, -0.893224, 0.898674, -0.903989,
        0.909168, -0.914210, 0.919114, -0.923880, 0.928506, -0.932993, 0.937339, -0.941544, 0.945607, -0.949528,
        0.953306, -0.956940, 0.960431, -0.963776, 0.966976, -0.970031, 0.972940, -0.975702, 0.978317, -0.980785,
        0.983105, -0.985278, 0.987301, -0.989177, 0.990903, -0.992480, 0.993907, -0.995185, 0.996313, -0.997290,
        0.998118, -0.998795, 0.999322, -0.999699, 0.999925, -1.000000, 0.999925, -0.999699, 0.999322, -0.998795,
        0.998118, -0.997290, 0.996313, -0.995185, 0.993907, -0.992480, 0.990903, -0.989177, 0.987301, -0.985278,
        0.983105, -0.980785, 0.978317, -0.975702, 0.972940, -0.970031, 0.966976, -0.963776, 0.960431, -0.956940,
        0.953306, -0.949528, 0.945607, -0.941544, 0.937339, -0.932993, 0.928506, -0.923880, 0.919114, -0.914210,
        0.909168, -0.903989, 0.898674, -0.893224, 0.887640, -0.881921, 0.876070, -0.870087, 0.863973, -0.857729,
        0.851355, -0.844854, 0.838225, -0.831470, 0.824589, -0.817585, 0.810457, -0.803208, 0.795837, -0.788346,
        0.780737, -0.773010, 0.765167, -0.757209, 0.749136, -0.740951, 0.732654, -0.724247, 0.715731, -0.707107,
        0.698376, -0.689541, 0.680601, -0.671559, 0.662416, -0.653173, 0.643832, -0.634393, 0.624859, -0.615232,
        0.605511, -0.595699, 0.585798, -0.575808, 0.565732, -0.555570, 0.545325, -0.534998, 0.524590, -0.514103,
        0.503538, -0.492898, 0.482184, -0.471397, 0.460539, -0.449611, 0.438616, -0.427555, 0.416430, -0.405241,
        0.393992, -0.382683, 0.371317, -0.359895, 0.348419, -0.336890, 0.325310, -0.313682, 0.302006, -0.290285,
        0.278520, -0.266713, 0.254866, -0.242980, 0.231058, -0.219101, 0.207111, -0.195090, 0.183040, -0.170962,
        0.158858, -0.146730, 0.134581, -0.122411, 0.110222, -0.098017, 0.085797, -0.073565, 0.061321, -0.049068,
        0.036807, -0.024541, 0.012272 };

float wtk_syn_sigmoid(float x, float a, float b)
{
	double s0, s1;
	s0 = 1.0 / (1.0 + exp(-1.0 * a * (0.0 - b)));
	s1 = 1.0 / (1.0 + exp(-1.0 * a * (1.0 - b)));

	return (1.0 / (1.0 + exp(-1.0 * a * (x - b))) - s0) / (s1 - s0);
}

void wtk_syn_cexp(float *xr, float *xi)
{
	double a;

	if (xr == NULL)
		return;
	else if (*xr == 0.0)
	{
		*xr = cos(*xi);
		*xi = sin(*xi);
	}
	else if (xi != NULL && *xi != 0.0)
	{
		a = exp(*xr);
		*xr = a * cos(*xi);
		*xi = a * sin(*xi);
	}
	else
		*xr = exp(*xr);

	return;
}

void wtk_syn_clog(float *xr, float *xi)
{
	double a;

	if (*xr < 0.0 || (xi != NULL && *xi != 0.0))
	{
		a = CABS(*xr, *xi);
		*xi = atan2(*xi, *xr);
		*xr = log(a);
	}
	else
	{
		if (*xr == 0.0)
		{
			if (sp_warning)
				fprintf(stderr, "warning: clog: log of zero\n");
			*xr = log(ALITTLE_NUMBER);
		}
		else
			*xr = log(*xr);
	}

	return;
}

void wtk_syn_fftshift(float *xRe, float *xIm, long fftp)
{
	long i;
	double value, value2;
	long hfftp = fftp / 2;
	long hfftp2 = fftp - hfftp;
	long hfftpm = hfftp - 1;

	if (xRe != NULL)
	{
		value2 = xRe[hfftp];
		xRe[hfftp] = xRe[fftp - 1]; /* if fft point is odd */
		for (i = 0; i < hfftpm; i++)
		{
			value = xRe[i];
			xRe[i] = value2;
			value2 = xRe[i + hfftp + 1];
			xRe[i + hfftp2] = value;
		}
		value = xRe[i];
		xRe[i] = value2;
		xRe[i + hfftp2] = value;
	}
	if (xIm != NULL)
	{
		value2 = xIm[hfftp];
		xIm[hfftp] = xIm[fftp - 1]; /* if fft point is odd */
		for (i = 0; i < hfftpm; i++)
		{
			value = xIm[i];
			xIm[i] = value2;
			value2 = xIm[i + hfftp + 1];
			xIm[i + hfftp2] = value;
		}
		value = xIm[i];
		xIm[i] = value2;
		xIm[i + hfftp2] = value;
	}

	return;
}

void wtk_syn_vector_dvifree(wtk_syn_vector_t *v)
{
	if (v->imag)
	{
		wtk_free(v->imag);
		v->imag = NULL;
	}
}

void wtk_syn_vector_dvialloc(wtk_syn_vector_t *v, float d)
{
	int k;

	wtk_syn_vector_dvifree(v);
	v->imag = wtk_malloc(sizeof(float)*v->len);
	for (k = 0; k < v->len; ++k)
	{
		v->imag[k] = d;
	}
}

void wtk_syn_fftturn(float *xRe, float *xIm, int fftp)
{
	long i;
	long hfftp = fftp - (fftp / 2);

	if (xRe != NULL)
	{
		for (i = 1; i < hfftp; i++)
		{
			xRe[fftp - i] = xRe[i];
		}
	}
	if (xIm != NULL)
	{
		for (i = 1; i < hfftp; i++)
		{
			xIm[fftp - i] = -xIm[i];
		}
	}
}

void wtk_syn_vector_dvfftturn(wtk_syn_vector_t *x)
{
	wtk_syn_fftturn(x->data, x->imag, x->len);
}

void wtk_syn_vector_dvfft(wtk_syn_vector_t *v, wtk_syn_fft_t *fft)
{
	if (!v->imag)
	{
		wtk_syn_vector_dvialloc(v, 0);
	}
	//wtk_syn_fft(v->data,v->imag,v->len,0);
	wtk_syn_fft_process(fft, v->data, v->imag, 0);
}

void wtk_syn_vector_dvifft(wtk_syn_vector_t *v, wtk_syn_fft_t *fft)
{
	if (!v->imag)
	{
		wtk_syn_vector_dvialloc(v, 0);
	}
	//wtk_syn_fft(v->data,v->imag,v->len,1);
	wtk_syn_fft_process(fft, v->data, v->imag, 1);
}

wtk_syn_vector_t* wtk_syn_vector_xdvcut(wtk_syn_vector_t *x, int offset,
		int len)
{
	long k, pos;
	wtk_syn_vector_t *y;

	y = wtk_syn_vector_new(len, 0);
	if (x->imag)
	{
		wtk_syn_vector_dvialloc(y, 0);
	}
	for (k = 0; k < y->len; ++k)
	{
		pos = k + offset;
		if (pos >= 0 && pos < x->len)
		{
			y->data[k] = x->data[pos];
			if (y->imag)
			{
				y->imag[k] = x->imag[pos];
			}
		}
		else
		{
			y->data[k] = 0;
			if (y->imag)
			{
				y->imag[k] = 0;
			}
		}
	}
	return y;
}

wtk_syn_vector_t* wtk_syn_vector_xdvfft(wtk_syn_vector_t *x, wtk_syn_fft_t *fft)
{
	wtk_syn_vector_t *y;

	y = wtk_syn_vector_dup(x);
	wtk_syn_vector_dvfft(y, fft);
	return y;
}

void wtk_syn_vector_dvfftshift(wtk_syn_vector_t *x)
{
	wtk_syn_fftshift(x->data, x->imag, x->len);
}

void wtk_syn_vector_dvcumsum(wtk_syn_vector_t *x)
{
	long k;
	double sum;

	for (k = 0, sum = 0.0; k < x->len; k++)
	{
		sum += x->data[k];
		x->data[k] = sum;
	}
	if (x->imag != NULL)
	{
		for (k = 0, sum = 0.0; k < x->len; k++)
		{
			sum += x->imag[k];
			x->imag[k] = sum;
		}
	}
	return;
}

wtk_syn_vector_t* wtk_syn_vector_xdvcumsum(wtk_syn_vector_t *x)
{
	wtk_syn_vector_t *y;

	y = wtk_syn_vector_dup(x);
	wtk_syn_vector_dvcumsum(y);
	return y;
}

void wtk_syn_rand_init(wtk_syn_rand_t *r)
{
	r->x = 1;
	r->a = 419;
	r->c = 6173;
	r->m = 29282;
	r->dvm=1.0/r->m;
}

float wtk_syn_rand_simple_random(wtk_syn_rand_t *r)
{
	r->x = (r->x * r->a + r->c) % (r->m);
	return r->x * r->dvm;//1.0 / r->m;
}

float wtk_syn_rand_simple_noise(wtk_syn_rand_t *r, float rms)
{
	float x, yy;

	yy = wtk_syn_rand_simple_random(r) + 1.0e-30;
	x = sqrt(-2. * log(yy)) * cos(2. * PI * wtk_syn_rand_simple_random(r))
			* rms;
	return x;
}

void wtk_syn_vector_dvrandn(wtk_syn_vector_t *v)
{
	wtk_syn_rand_t rnd;
	int k;

//	if (v->data)
//	{
//		memset(v->data, 0, v->len * sizeof(float));
//	}
//	if (v->imag)
//	{
//		memset(v->imag, 0, v->len * sizeof(float));
//	}
//	return;
	wtk_syn_rand_init(&(rnd));
	for (k = 0; k < v->len; ++k)
	{
		v->data[k] = wtk_syn_rand_simple_noise(&(rnd), 1.0);
		//v->data[k]=0;
		//printf("data[%d]=%f\n", k, v->data[k]);
	}
	if (v->imag)
	{
		for (k = 0; k < v->len; ++k)
		{
			v->imag[k] = wtk_syn_rand_simple_noise(&(rnd), 1.0);
			//v->imag[k]=0;
		}
	}
}

wtk_syn_vector_t* wtk_syn_vector_new(int len, float v)
{
	wtk_syn_vector_t *sv;
	int i;

	sv = (wtk_syn_vector_t*) wtk_malloc(sizeof(wtk_syn_vector_t));
	sv->len = len;
	sv->data = wtk_malloc(len*sizeof(wtk_syn_float_t));
	sv->imag = NULL;
	if(v==0)
	{
		memset(sv->data,0,len*sizeof(float));
	}else
	{
		for (i = 0; i < len; ++i)
		{
			sv->data[i] = v;
		}
	}
	return sv;
}

wtk_syn_vector_t* wtk_syn_vector_new_h(wtk_heap_t *h,int len, float v)
{
	wtk_syn_vector_t *sv;
	int i;

	sv = (wtk_syn_vector_t*) wtk_heap_malloc(h,sizeof(wtk_syn_vector_t));
	sv->len = len;
	sv->data = wtk_heap_malloc(h,len*sizeof(wtk_syn_float_t));
	sv->imag = NULL;
	if(v==0)
	{
		memset(sv->data,0,len*sizeof(float));
	}else
	{
		for (i = 0; i < len; ++i)
		{
			sv->data[i] = v;
		}
	}
	return sv;
}

wtk_syn_vector_t* wtk_syn_vector_dup(wtk_syn_vector_t *x)
{
	wtk_syn_vector_t *y;

	y = (wtk_syn_vector_t*) wtk_malloc(sizeof(wtk_syn_vector_t));
	y->len = x->len;
	if (x->data)
	{
		y->data = wtk_malloc(x->len*sizeof(wtk_syn_float_t));
		memcpy(y->data, x->data, x->len * sizeof(wtk_syn_float_t));
	}
	else
	{
		y->data = NULL;
	}
	if (x->imag)
	{
		y->imag = wtk_malloc(y->len*sizeof(wtk_syn_float_t));
		memcpy(y->imag, x->imag, x->len * sizeof(wtk_syn_float_t));
	}
	else
	{
		y->imag = NULL;
	}
	return y;
}

void wtk_syn_vector_delete(wtk_syn_vector_t *sv)
{
	if(sv->imag)
	{
		wtk_free(sv->imag);
	}
	wtk_free(sv->data);
	wtk_free(sv);
}

void wtk_syn_vector_print(wtk_syn_vector_t *v)
{
	int i;

	for (i = 0; i < v->len; ++i)
	{
		wtk_debug("v[%d]= %f\n", i, v->data[i]);
	}
}

wtk_syn_vocoder_t* wtk_syn_vocoder_new(wtk_syn_hmm_cfg_t *cfg, int m)
{
	wtk_syn_vocoder_t *v;

	v = (wtk_syn_vocoder_t*) wtk_malloc(sizeof(wtk_syn_vocoder_t));
	v->order = m;
	v->iprd = 1;
	v->pd = 5;
	v->alpha = cfg->alpha;
	v->alpha2=1-v->alpha*v->alpha;
	v->beta = cfg->beta;
	v->pade[0] = 1.0;
	v->pade[1] = 1.0;
	v->pade[2] = 0.0;
	v->pade[3] = 1.0;
	v->pade[4] = 0.0;
	v->pade[5] = 0.0;
	v->pade[6] = 1.0;
	v->pade[7] = 0.0;
	v->pade[8] = 0.0;
	v->pade[9] = 0.0;
	v->pade[10] = 1.0;
	v->pade[11] = 0.4999273;
	v->pade[12] = 0.1067005;
	v->pade[13] = 0.01170221;
	v->pade[14] = 0.0005656279;
	v->pade[15] = 1.0;
	v->pade[16] = 0.4999391;
	v->pade[17] = 0.1107098;
	v->pade[18] = 0.01369984;
	v->pade[19] = 0.0009564853;
	v->pade[20] = 0.00003041721;
	v->ppade = &(v->pade[v->pd * (v->pd + 1) / 2]);
	v->pb = (wtk_syn_float_t*) wtk_calloc(3 * (v->order + 1) + 3 * (v->pd + 1)
			+ v->pd * (v->order + 2), sizeof(wtk_syn_float_t));
	v->cb = v->pb + v->order + 1;
	v->binc = v->cb + v->order + 1;
	v->d1 = v->binc + v->order + 1;

	if (v->beta > 0 && v->order > 1)
	{
		v->irleng = 96;
		v->pfmc =
				(wtk_syn_float_t*) wtk_calloc((v->order + 1) + 2 * v->irleng, sizeof(wtk_syn_float_t));
		v->pfcep = v->pfmc + v->order + 1;
		v->pfir = v->pfcep + v->irleng;
		v->pfd =
				(wtk_syn_float_t*) wtk_calloc(v->irleng*2,sizeof(wtk_syn_float_t));
		v->pfg = v->pfd + v->irleng;
	}
	else
	{
		v->pfmc = NULL;
		v->pfcep = NULL;
		v->pfir = NULL;
		v->pfd = NULL;
		v->pfg = NULL;
	}
	v->ncpy=sizeof(float)*(v->order-1);
	return v;
}

int wtk_syn_vocoder_bytes(wtk_syn_vocoder_t* v)
{
	int bytes;

	bytes=(3 * (v->order + 1) + 3 * (v->pd + 1)
					+ v->pd * (v->order + 2))*sizeof(wtk_syn_float_t);
	if(v->pfmc)
		bytes+=((v->order + 1) + 2 * v->irleng)* sizeof(wtk_syn_float_t);
	if(v->pfd)
		bytes+=v->irleng*2 * sizeof(wtk_syn_float_t);
	return bytes;
}

void wtk_syn_vocoder_delete(wtk_syn_vocoder_t *v)
{
	wtk_free(v->pb);
	if(v->pfmc)
	{
		wtk_free(v->pfmc);
	}
	if(v->pfd)
	{
		wtk_free(v->pfd);
	}
	wtk_free(v);
}



/* mc2b: transform mel-cepstrum to MLSA digital fillter coefficients */
void wtk_syn_vocoder_mc2b(wtk_syn_vocoder_t *vs, float *mc)
{
	const double a = vs->alpha;
	int m = vs->order;

	vs->cb[m] = mc[m];
	for (m--; m >= 0; m--)
	{
		vs->cb[m] = mc[m] - a * vs->cb[m + 1];
	}
	return;
}

/* b2bc: transform MLSA digital filter coefficients to mel-cepstrum */
void wtk_syn_vocoder_b2mc(wtk_syn_vocoder_t *vs)
{
	const double a = vs->alpha;
	int m = vs->order;
	double d, o;

	d = vs->pfmc[m] = vs->cb[m];
	for (m--; m >= 0; m--)
	{
		o = vs->cb[m] + a * d;
		d = vs->cb[m];
		vs->pfmc[m] = o;
	}
	return;
}

/* movem: move */
void movem(float *a, float *b, const int nitem)
{
	long i = (long) nitem;

	if (a > b)
	{
		while (i--)
		{
			*b++ = *a++;
		}
	}
	else
	{
		a += i;
		b += i;
		while (i--)
		{
			*--b = *--a;
		}
	}
	return;
}

/* freqt: frequency transformation */
void wtk_syn_vocoder_freqt(wtk_syn_vocoder_t *vs)
{
	const int m1 = vs->order;
	const int m2 = vs->irleng - 1;
	const double a = -vs->alpha;
	int i, j;
	double b;

	b = 1 - a * a;
	for (i = 0; i < m2 + 1; i++)
	{
		vs->pfg[i] = 0.0;
	}
	for (i = -m1; i <= 0; i++)
	{
		if (0 <= m2)
		{
			vs->pfg[0] = vs->pfmc[-i] + a * (vs->pfd[0] = vs->pfg[0]);
		}
		if (1 <= m2)
		{
			vs->pfg[1] = b * vs->pfd[0] + a * (vs->pfd[1] = vs->pfg[1]);
		}
		for (j = 2; j <= m2; j++)
		{
			vs->pfg[j] = vs->pfd[j - 1]
					+ a * ((vs->pfd[j] = vs->pfg[j]) - vs->pfg[j - 1]);
		}
	}

	movem(vs->pfg, vs->pfcep, m2 + 1);

	return;
}

/* c2ir: The minimum phase impulse response is evaluated from the minimum phase cepstrum */
void wtk_syn_vocoder_c2ir(wtk_syn_vocoder_t *vs)
{
	const int nc = vs->irleng;
	const int leng = vs->irleng;
	int n, k, upl;
	double d;

	vs->pfir[0] = exp(vs->pfcep[0]);
	for (n = 1; n < leng; n++)
	{
		d = 0;
		upl = (n >= nc) ? nc - 1 : n;
		for (k = 1; k <= upl; k++)
		{
			d += k * vs->pfcep[k] * vs->pfir[n - k];
		}
		vs->pfir[n] = d / n;
	}
	return;
}

float wtk_syn_vocoder_b2en(wtk_syn_vocoder_t *vs)
{
	int k;
	double en;

	wtk_syn_vocoder_b2mc(vs);
	wtk_syn_vocoder_freqt(vs);
	wtk_syn_vocoder_c2ir(vs);
	for (k = 0, en = 0.0; k < vs->irleng; k++)
	{
		en += vs->pfir[k] * vs->pfir[k];
	}
	return (en);
}

// postfiltering
void wtk_syn_vocoder_postfilter(wtk_syn_vocoder_t *vc, float *mc)
{
	int k;
	double e1, e2;

	e1 = wtk_syn_vocoder_b2en(vc);
	vc->cb[1] -= vc->beta * vc->alpha * mc[2];
	for (k = 2; k <= vc->order; k++)
	{
		vc->cb[k] *= (1.0 + vc->beta);
	}
	e2 = wtk_syn_vocoder_b2en(vc);
	vc->cb[0] += log(e1 / e2) / 2;
	for (k = 0; k <= vc->order; k++)
	{
		mc[k] = vc->pfmc[k];
	}
	return;
}

float wtk_syn_vocoder_mlsadf1(wtk_syn_vocoder_t *vs, float x, float *d)
{
	float a = vs->alpha;
	float aa = 1 - vs->alpha * vs->alpha;
	register float v, out = 0.0;
	float *pt;
	int i;
	register float *f1,*f2,*f3;
	float *f4;
	float tf;

	tf=vs->pb[1];
	pt = &d[vs->pd + 1];
	for (i = vs->pd,f1=d+i,f2=pt+vs->pd,f3=vs->ppade+vs->pd,f4=pt+i; i >= 1;--i,--f1,--f2,--f3,--f4)
	{
		*f1 = aa * *(f2-1) + a * *f1;
		*f2 = *f1 * tf;
		v = *f4 * *f3;//pt[i] * *f3;
		x += (1 & i) ? v : -v;
		out += v;
		//if(*f1!=0 || *f2!=0)exit(0);
	}

	pt[0] = x;
	out += x;

	return (out);
}

float wtk_syn_vocoder_mlsafir2(wtk_syn_vocoder_t *vs, float x, float *d)
{
	register float *fs, *fe, *fs2;
	int m;
	float a, aa;
	float y = 0.0;

	m = vs->order;
	a = vs->alpha;
	aa = 1 - a * a;
	d[0] = x;
	d[1] = aa * d[0] + a * d[1];
	fs = d + 2;
	fe = d + m;
	while (fs <= fe)
	{
		*(fs) += a * (*(fs + 1) - *(fs - 1));
		++fs;
	}
	fs = d + 1;
	fs2 = vs->pb + 1;
	while (fs < fe)
	{
		y += *(++fs) * (*(++fs2));
	}
	//memmove(d+m+1,d+m,sizeof(float)*m);
	//exit(0);
	fs = d + 2;
	fe = d + m + 2;
	fs2 = d + m+1;
	while (fe > fs)
	{
		*(--fe) = *(--fs2);
	}
	return (y);
}

float wtk_syn_vocoder_mlsafir(wtk_syn_vocoder_t *vs, float x, float *d)
{
	float a = vs->alpha;
	register float y = 0.0;
	register float *f,*fb,*fe;
	int col;

	f=d;
	*(f++) = x;
	*f = vs->alpha2 * x + a * *f;
	f=d+2;fb=vs->pb+1;
	col=((vs->order-2)>>3)<<3;
	fe=f+col;
	//wtk_debug("col= %d / %d\n",col,vs->order);
	while(f<fe)
	{
		f[0]+=(f[1]-f[-1])*a;
		f[1]+=(f[2]-f[0])*a;
		f[2]+=(f[3]-f[1])*a;
		f[3]+=(f[4]-f[2])*a;
		f[4]+=(f[5]-f[3])*a;
		f[5]+=(f[6]-f[4])*a;
		f[6]+=(f[7]-f[5])*a;
		f[7]+=(f[8]-f[6])*a;

		y+=f[0]* fb[1];
		y+=f[1]* fb[2];
		y+=f[2]* fb[3];
		y+=f[3]* fb[4];
		y+=f[4]* fb[5];
		y+=f[5]* fb[6];
		y+=f[6]* fb[7];
		y+=f[7]* fb[8];

		//wtk_debug("f=%p/%p\n",f,fe);
		f+=8;
		fb+=8;
	}
	fe=d+vs->order;
	while(f<=fe)
	{
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
	}
    memmove(d + 1,d, vs->ncpy);//sizeof(float) * (vs->order-1));
	return y;
}


float wtk_syn_vocoder_mlsafir5(wtk_syn_vocoder_t *vs, float x, float *d)
{
	float a = vs->alpha;
	register float y = 0.0;
	register float *f,*fb,*fe;
	int col;

	f=d;
	*(f++) = x;
	*f = vs->alpha2 * x + a * *f;
	f=d+2;fb=vs->pb+1;
	col=((vs->order-2)>>3)<<3;
	fe=f+col;
	//wtk_debug("col=%d/%d\n",col,vs->order);
	while(f<fe)
	{
		f[0]+=(f[1]-f[-1])*a;
		y+=f[0]* fb[1];

		f[1]+=(f[2]-f[0])*a;
		y+=f[1]* fb[2];

		f[2]+=(f[3]-f[1])*a;
		y+=f[2]* fb[3];

		f[3]+=(f[4]-f[2])*a;
		y+=f[3]* fb[4];

		f[4]+=(f[5]-f[3])*a;
		y+=f[4]* fb[5];

		f[5]+=(f[6]-f[4])*a;
		y+=f[5]* fb[6];

		f[6]+=(f[7]-f[5])*a;
		y+=f[6]* fb[7];

		f[7]+=(f[8]-f[6])*a;
		y+=f[7]* fb[8];

		//wtk_debug("f=%p/%p\n",f,fe);
		f+=8;
		fb+=8;
	}
	fe=d+vs->order;
	while(f<=fe)
	{
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
	}
    memmove(d + 1,d, vs->ncpy);//sizeof(float) * (vs->order-1));
	return y;
}

float wtk_syn_vocoder_mlsafir4(wtk_syn_vocoder_t *vs, float x, float *d)
{
	float a = vs->alpha;
	register float y = 0.0;
	register float *f,*fb,*fe;

	f=d;
	*(f++) = x;
	*f = vs->alpha2 * x + a * *f;
	f=d+2;fb=vs->pb+1;
	fe=d+vs->order-8;
	while(f<=fe)
	{
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
	}
	fe=d+vs->order;
	while(f<=fe)
	{
		y+= (*(f)+= a * (*(f+1) - *(f-1))) * *(++fb);
		++f;
	}
    memmove(d + 1,d, vs->ncpy);//sizeof(float) * (vs->order-1));
	return y;
}


float wtk_syn_vocoder_mlsafir3(wtk_syn_vocoder_t *vs, float x, float *d)
{
	const int m = vs->order;
	const float a = vs->alpha;
	const float aa = 1 - vs->alpha * vs->alpha;
	float y = 0.0;
	int i;

	d[0] = x;
	d[1] = aa * d[0] + a * d[1];
	for (i = 2; i <= m; i++)
	{
		d[i] += a * (d[i + 1] - d[i - 1]);
	}
	for (i = 2; i <= m; i++)
	{
		y += d[i] * vs->pb[i];
	}
	for (i = m + 1; i > 1; i--)
	{
		d[i] = d[i - 1];
	}
	return (y);
}

float wtk_syn_vocoder_mlsadf2(wtk_syn_vocoder_t *vs, float x, float *d)
{
	int m = vs->order;
	register float v, out = 0.0;
	float *pt;
	register float *f,*f1,*f2;
	int i;

	pt = &d[vs->pd * (m + 2)];
	f2=d+(vs->pd-1)*(m+2);
	for (i = vs->pd,f=pt+i,f1=vs->ppade+i; i >= 1; --i,--f,--f1,f2-=m+2)
	{
		*f = wtk_syn_vocoder_mlsafir(vs, *(f-1), f2);//&d[(i - 1) * (m + 2)]);
		v = *f * *f1;
		x += (1 & i) ? v : -v;
		out += v;
	}
	pt[0] = x;
	out += x;
	return (out);
}

float wtk_syn_vocoder_mlsadf2_2(wtk_syn_vocoder_t *vs, float x, float *d)
{
	const int m = vs->order;
	double v, out = 0.0;
	float *pt;
	int i;

	pt = &d[vs->pd * (m + 2)];

	for (i = vs->pd; i >= 1; i--)
	{
		pt[i] = wtk_syn_vocoder_mlsafir(vs, pt[i - 1], &d[(i - 1) * (m + 2)]);
		v = pt[i] * vs->ppade[i];
		x += (1 & i) ? v : -v;
		out += v;
	}

	pt[0] = x;
	out += x;

	return (out);
}

float wtk_syn_vocoder_mlsadf(wtk_syn_vocoder_t *vs, float x)
{
	x = wtk_syn_vocoder_mlsadf1(vs, x, vs->d1);
	x = wtk_syn_vocoder_mlsadf2(vs, x, &vs->d1[2 * (vs->pd + 1)]);
	return x;
}

/* AIS_Vocoder: excitation signal and MLSA filster based waveform synthesis */
void wtk_syn_vocoder_mlsafilter(wtk_syn_vocoder_t *vs,register float *x, float *mc,
		int len)
{
	int i;//, j;//, k;
	//short xs;
	int m = vs->order;
	register float f,ft;
	register float *f1,*f2,*f3,*fe;

	//wtk_debug("vs->order= %d\n", vs->order);
	wtk_syn_vocoder_mc2b(vs, mc);
	if (vs->pfmc && vs->pfd)
	{
		/* postfiltering */
		wtk_syn_vocoder_postfilter(vs, mc);
	}
	f=vs->iprd*1.0/len;
	f1=vs->binc;
	f2=vs->cb;
	f3=vs->pb;
	fe=f1+m;
	while(f1<=fe)
	{
		*(f1++)=(*(f2++) - *(f3++)) *f;
	}
	f=exp(vs->pb[0]);
	fe=x+len;
	i = (vs->iprd + 1) / 2;
	f3=vs->pb+m;
	while(x<fe)
	{
		ft=*x * f;
		//*x *=f;
		*(x) = wtk_syn_vocoder_mlsadf(vs,ft);
		++x;
		if (!--i)
		{
			f1=vs->pb;
			f2=vs->binc;
			while(f1<=f3)
			{
				*(f1++) += *(f2++);
			}
			i = vs->iprd;
		}
	}
	movem(vs->cb, vs->pb, m + 1);
	//exit(0);
	return;
}

void wtk_syn_vocoder_mlsafilter2(wtk_syn_vocoder_t *vs, float *x, float *mc,
		int len)
{
	int m = vs->order;
	int i;

	for (i = 0; i < m; ++i)
	{
		wtk_debug("v[%d]=%f\n", i, x[i]);
	}
	wtk_syn_vocoder_mlsafilter(vs, x, mc, len);
}

// smoothing phase transition window
wtk_syn_vector_t* wtk_syn_vector_xphstranswin(int fftl)
{
	wtk_syn_vector_t *v;
	int k;
	int fftl2;

	fftl2 = fftl / 2;
	v = wtk_syn_vector_new(fftl, 0);
	for (k = 0; k < v->len; ++k)
	{
		v->data[k] = 1.0 / (1.0 + exp((k - fftl2) * (-40.0) / fftl));
	}
	return v;
}

void wtk_syn_vector_dvscoper(wtk_syn_vector_t *x, char* op, float t)
{
	long k;
	int reverse = 0;
	const char *op2 = op;

	if (strveq(op2, "!"))
	{
		reverse = 1;
		op2++;
	}

	if (strveq(op2, "+"))
	{
		for (k = 0; k < x->len; k++)
		{
			x->data[k] = x->data[k] + t;
		}
	}
	else if (strveq(op2, "-"))
	{
		for (k = 0; k < x->len; k++)
		{
			if (reverse)
			{
				x->data[k] = t - x->data[k];
				if (x->imag != NULL)
				{
					x->imag[k] = -x->imag[k];
				}
			}
			else
			{
				x->data[k] = x->data[k] - t;
			}
		}
	}
	else if (strveq(op2, "*"))
	{
		for (k = 0; k < x->len; k++)
		{
			x->data[k] = x->data[k] * t;
			if (x->imag != NULL)
			{
				x->imag[k] = x->imag[k] * t;
			}
		}
	}
	else if (strveq(op2, "/"))
	{
		double a;
		for (k = 0; k < x->len; k++)
		{
			if (reverse)
			{
				if (x->imag != NULL)
				{
					if (x->data[k] == 0.0 && x->imag[k] == 0.0)
					{
						if (sp_warning)
							fprintf(stderr,
									"warning: dvscoper: divide by zero\n");
						if (t == 0.0)
						{
							x->data[k] = 0.0;
						}
						else
						{
							x->data[k] = t / ALITTLE_NUMBER;
						}
						x->imag[k] = 0.0;
					}
					else
					{
						a = CSQUARE(x->data[k], x->imag[k]);
						x->data[k] = x->data[k] * t / a;
						x->imag[k] = -x->imag[k] * t / a;
					}
				}
				else
				{
					if (x->data[k] != 0.0)
					{
						x->data[k] = t / x->data[k];
					}
					else
					{
						if (sp_warning)
							fprintf(stderr,
									"warning: dvscoper: divide by zero\n");
						if (t == 0.0)
						{
							x->data[k] = 0.0;
						}
						else
						{
							x->data[k] = t / ALITTLE_NUMBER;
						}
					}
				}
			}
			else
			{
				if (t != 0.0)
				{
					x->data[k] = x->data[k] / t;
					if (x->imag != NULL)
					{
						x->imag[k] = x->imag[k] / t;
					}
				}
				else
				{
					if (x->data[k] == 0.0)
					{
						x->data[k] = 0.0;
					}
					else
					{
						x->data[k] = x->data[k] / ALITTLE_NUMBER;
					}
					if (x->imag != NULL)
					{
						if (x->imag[k] == 0.0)
						{
							x->imag[k] = 0.0;
						}
						else
						{
							x->imag[k] = x->imag[k] / ALITTLE_NUMBER;
						}
					}
				}
			}
		}
	}
	else if (strveq(op2, "^"))
	{
		double a;
		for (k = 0; k < x->len; k++)
		{
			if (reverse)
			{
				if (x->imag != NULL && x->imag[k] != 0.0)
				{
					a = log(t);
					x->data[k] *= a;
					x->imag[k] *= a;
					wtk_syn_cexp(&x->data[k], &x->imag[k]);
				}
				else
				{
					x->data[k] = pow(t, x->data[k]);
				}
			}
			else
			{
				if (x->imag != NULL && x->imag[k] != 0.0)
				{
					wtk_syn_clog(&x->data[k], &x->imag[k]);
					x->data[k] *= t;
					x->imag[k] *= t;
					wtk_syn_cexp(&x->data[k], &x->imag[k]);
				}
				else
				{
					x->data[k] = pow(x->data[k], t);
				}
			}
		}
	}
	else
	{
		fprintf(stderr, "dvscoper: unknouwn operation: %s\n", op2);
		exit(1);
	}

	return;
}

void wtk_syn_vector_dvoper(wtk_syn_vector_t *x, const char *op,
		wtk_syn_vector_t *y)
{
	long k;
	int reverse = 0;
	const char *op2 = op;
	register float *fx,*fy,*ifx,*ify;
	float  xr, xi,a;
	int v;

	if (strveq(op2, "!"))
	{
		reverse = 1;
		op2++;
	}

	if (y->imag != NULL && x->imag == NULL)
	{
		wtk_syn_vector_dvialloc(x, 0);
	}

	if (strveq(op2, "*"))
	{

		ifx=x->imag;
		ify=y->imag;
		if(ifx)
		{
			v=min(x->len,y->len);
			if(ify)
			{
				for (k = 0,fx=x->data,fy=y->data; k < v; ++k,++fx,++fy,++ifx,++ify)
				{
					xr=*fx * *fy - *ifx * *ify;
					xi=*fx * *ify + *ifx * *fy;
					*fx=xr;
					*ifx=xi;
				}
			}else
			{
				for (k = 0,fx=x->data,fy=y->data; k < v; ++k,++fx,++fy,++ifx)
				{
					*fx=*fx * *fy;
					*ifx=*ifx * *fy;
				}
			}
			v=x->len-k;
			if(v>0)
			{
				memset(fx,0,sizeof(float)*v);
				memset(ifx,0,sizeof(float)*v);
			}
		}else
		{
			v=min(x->len,y->len);
			for (k = 0,fx=x->data,fy=y->data;k<v; ++k,++fx,++fy)
			{
				*fx=*fx * *fy;
			}
			v=x->len-k;
			if(v>0)
			{
				memset(fx,0,sizeof(float)*v);
			}
		}
	}else	if (strveq(op2, "+"))
	{
		if(x->imag && y->imag)
		{
			ifx=x->imag;
			ify=y->imag;
			for (k = 0,fx=x->data,fy=y->data; k < x->len && k<y->len; ++k,++fx,++fy,++ifx,++ify)
			{
				*fx=*fx+*fy;
				*ifx=*ifx+*ify;
			}
		}else
		{
			for (k = 0,fx=x->data,fy=y->data; k < x->len && k<y->len; ++k,++fx,++fy)
			{
				*fx=*fx+*fy;
			}
		}
	}
	else if (strveq(op2, "-"))
	{
		if (reverse)
		{
			ifx=x->imag;
			ify=y->imag;
			if(ifx)
			{
				for (k = 0,fx=x->data,fy=y->data; k < x->len; ++k,++fx,++fy)
				{
					if (k < y->len)
					{
						*fx=*fy-*fx;
						*(ifx)=ify?(*(ify++)-*ifx):-*ifx;
						++ifx;
					}
					else
					{
						*fx=-*fx;
						*(ifx)=-*ifx;
						++ifx;
					}
				}
			}else
			{
				for (k = 0,fx=x->data,fy=y->data; k < x->len; ++k,++fx,++fy)
				{
					if (k < y->len)
					{
						*fx=*fy-*fx;
					}
					else
					{
						*fx=-*fx;
					}
				}
			}
		}
		else
		{
			v=min(x->len,y->len);
			ifx=x->imag;
			ify=y->imag;
			if(ifx && ify)
			{
				for (k = 0,fx=x->data,fy=y->data; k < v; ++k,++fx,++fy,++ifx,++ify)
				{
					*fx=*fx-*fy;
					*ifx=*ifx-*ify;
				}
			}else
			{
				for (k = 0,fx=x->data,fy=y->data; k < v; ++k,++fx,++fy)
				{
					*fx=*fx-*fy;
				}
			}
		}
	}
	else if (strveq(op2, "/"))
	{

		if (reverse)
		{
			for (k = 0; k < x->len; k++)
			{
				if (k < y->len)
				{
					if (x->imag != NULL)
					{
						if (x->data[k] == 0.0 && x->imag[k] == 0.0)
						{
							if (sp_warning)
								fprintf(stderr,
										"warning: dvoper: divide by zero\n");
							if (y->data[k] == 0.0)
							{
								x->data[k] = 0.0;
							}
							else
							{
								x->data[k] = y->data[k] / ALITTLE_NUMBER;
							}
							if (y->imag != NULL)
							{
								if (y->imag[k] == 0.0)
								{
									x->imag[k] = 0.0;
								}
								else
								{
									x->imag[k] = y->imag[k] / ALITTLE_NUMBER;
								}
							}
							else
							{
								x->imag[k] = 0.0;
							}
						}
						else
						{
							a = CSQUARE(x->data[k], x->imag[k]);
							if (y->imag != NULL)
							{
								xr = x->data[k] * y->data[k]
										+ x->imag[k] * y->imag[k];
								xi = x->data[k] * y->imag[k]
										- x->imag[k] * y->data[k];
								x->data[k] = xr / a;
								x->imag[k] = xi / a;
							}
							else
							{
								x->data[k] = x->data[k] * y->data[k] / a;
								x->imag[k] = -x->imag[k] * y->data[k] / a;
							}
						}
					}
					else
					{
						if (x->data[k] != 0.0)
						{
							x->data[k] = y->data[k] / x->data[k];
						}
						else
						{
							if (sp_warning)
								fprintf(stderr,
										"warning: dvoper: divide by zero\n");
							if (y->data[k] == 0.0)
							{
								x->data[k] = 0.0;
							}
							else
							{
								x->data[k] = y->data[k] / ALITTLE_NUMBER;
							}
						}
					}
				}
				else
				{
					x->data[k] = 0.0;
					if (x->imag != NULL)
					{
						x->imag[k] = 0.0;
					}
				}
			}
		}
		else
		{
			for (k = 0; k < x->len; k++)
			{
				if (k < y->len)
				{
					if (x->imag != NULL && y->imag != NULL)
					{
						if (y->data[k] == 0.0 && y->imag[k] == 0.0)
						{
							if (sp_warning)
								fprintf(stderr,
										"warning: dvoper: divide by zero\n");
							if (x->data[k] == 0.0)
							{
								x->data[k] = 0.0;
							}
							else
							{
								x->data[k] = x->data[k] / ALITTLE_NUMBER;
							}
							if (x->imag[k] == 0.0)
							{
								x->imag[k] = 0.0;
							}
							else
							{
								x->imag[k] = x->imag[k] / ALITTLE_NUMBER;
							}
						}
						else
						{
							a = CSQUARE(y->data[k], y->imag[k]);
							xr = x->data[k] * y->data[k]
									+ x->imag[k] * y->imag[k];
							xi = -x->data[k] * y->imag[k]
									+ x->imag[k] * y->data[k];
							x->data[k] = xr / a;
							x->imag[k] = xi / a;
						}
					}
					else
					{
						if (y->data[k] == 0.0)
						{
							if (sp_warning)
								fprintf(stderr,
										"warning: dvoper: divide by zero\n");
							if (x->data[k] == 0.0)
							{
								x->data[k] = 0.0;
							}
							else
							{
								x->data[k] = x->data[k] / ALITTLE_NUMBER;
							}
							if (x->imag != NULL)
							{
								if (x->imag[k] == 0.0)
								{
									x->imag[k] = 0.0;
								}
								else
								{
									x->imag[k] = x->imag[k] / ALITTLE_NUMBER;
								}
							}
						}
						else
						{
							x->data[k] = x->data[k] / y->data[k];
							if (x->imag != NULL)
							{
								x->imag[k] = x->imag[k] / y->data[k];
							}
						}
					}
				}
				else
				{
					x->data[k] = 0.0;
					if (x->imag != NULL)
					{
						x->imag[k] = 0.0;
					}
				}
			}
		}
	}
	else if (strveq(op2, "^"))
	{
		float xr, xi;
		float yr, yi;
		if (reverse)
		{
			if (x->imag != NULL)
			{
				for (k = 0; k < x->len; k++)
				{
					if (k < y->len)
					{
						if (y->imag == NULL)
						{
							yr = y->data[k];
							yi = 0.0;
						}
						else
						{
							yr = y->data[k];
							yi = y->imag[k];
						}
						if (yr == 0.0 && yi == 0.0)
						{
							x->data[k] = 0.0;
							x->imag[k] = 0.0;
						}
						else if (x->imag[k] == 0.0 && yi == 0.0)
						{
							x->data[k] = pow(y->data[k], x->data[k]);
						}
						else
						{
							wtk_syn_clog(&yr, &yi);
							xr = x->data[k] * yr - x->imag[k] * yi;
							xi = x->data[k] * yi + x->imag[k] * yr;
							wtk_syn_cexp(&xr, &xi);
							x->data[k] = xr;
							x->imag[k] = xi;
						}
					}
					else
					{
						x->data[k] = 0.0;
						x->imag[k] = 0.0;
					}
				}
			}
			else
			{
				for (k = 0; k < x->len; k++)
				{
					if (k < y->len)
					{
						x->data[k] = pow(y->data[k], x->data[k]);
					}
					else
					{
						x->data[k] = 0.0;
					}
				}
			}
		}
		else
		{
			if (x->imag != NULL)
			{
				for (k = 0; k < x->len; k++)
				{
					if (k < y->len)
					{
						if (x->data[k] == 0.0 && x->imag[k] == 0.0)
						{
							x->data[k] = 0.0;
							x->imag[k] = 0.0;
						}
						else
						{
							if (y->imag == NULL)
							{
								yr = y->data[k];
								yi = 0.0;
							}
							else
							{
								yr = y->data[k];
								yi = y->imag[k];
							}
							if (x->imag[k] == 0.0 && yi == 0.0)
							{
								x->data[k] = pow(x->data[k], y->data[k]);
							}
							else
							{
								wtk_syn_clog(&x->data[k], &x->imag[k]);
								xr = x->data[k] * yr - x->imag[k] * yi;
								xi = x->data[k] * yi + x->imag[k] * yr;
								wtk_syn_cexp(&xr, &xi);
								x->data[k] = xr;
								x->imag[k] = xi;
							}
						}
					}
					else
					{
						x->data[k] = 1.0;
						x->imag[k] = 1.0;
					}
				}
			}
			else
			{
				for (k = 0; k < x->len; k++)
				{
					if (k < y->len)
					{
						x->data[k] = pow(x->data[k], y->data[k]);
					}
					else
					{
						x->data[k] = 1.0;
					}
				}
			}
		}
	}
	else
	{
		fprintf(stderr, "dvoper: unknouwn operation: %s\n", op2);
		exit(1);
	}
	return;
}

void wtk_syn_vector_dvoper2(wtk_syn_vector_t *x, const char *op,
		wtk_syn_vector_t *y)
{
	long k;
	int reverse = 0;
	const char *op2 = op;

	if (strveq(op2, "!"))
	{
		reverse = 1;
		op2++;
	}

	if (y->imag != NULL && x->imag == NULL)
	{
		wtk_syn_vector_dvialloc(x, 0);
	}

	if (strveq(op2, "+"))
	{
		for (k = 0; k < x->len; k++)
		{
			if (k < y->len)
			{
				x->data[k] = x->data[k] + y->data[k];
				if (x->imag != NULL)
				{
					if (y->imag != NULL)
					{
						x->imag[k] = x->imag[k] + y->imag[k];
					}
				}
			}
		}
	}
	else if (strveq(op2, "-"))
	{
		if (reverse)
		{
			for (k = 0; k < x->len; k++)
			{
				if (k < y->len)
				{
					x->data[k] = y->data[k] - x->data[k];
					if (x->imag != NULL)
					{
						if (y->imag != NULL)
						{
							x->imag[k] = y->imag[k] - x->imag[k];
						}
						else
						{
							x->imag[k] = -x->imag[k];
						}
					}
				}
				else
				{
					x->data[k] = -x->data[k];
					if (x->imag != NULL)
					{
						x->imag[k] = -x->imag[k];
					}
				}
			}
		}
		else
		{
			for (k = 0; k < x->len; k++)
			{
				if (k < y->len)
				{
					x->data[k] = x->data[k] - y->data[k];
					if (x->imag != NULL)
					{
						if (y->imag != NULL)
						{
							x->imag[k] = x->imag[k] - y->imag[k];
						}
					}
				}
			}
		}
	}
	else if (strveq(op2, "*"))
	{
		double xr, xi;
		for (k = 0; k < x->len; k++)
		{
			if (k < y->len)
			{
				if (x->imag != NULL)
				{
					if (y->imag != NULL)
					{
						xr = x->data[k] * y->data[k] - x->imag[k] * y->imag[k];
						xi = x->data[k] * y->imag[k] + x->imag[k] * y->data[k];
						x->data[k] = xr;
						x->imag[k] = xi;
					}
					else
					{
						x->data[k] = x->data[k] * y->data[k];
						x->imag[k] = x->imag[k] * y->data[k];
					}
				}
				else
				{
					x->data[k] = x->data[k] * y->data[k];
				}
			}
			else
			{
				x->data[k] = 0.0;
				if (x->imag != NULL)
				{
					x->imag[k] = 0.0;
				}
			}
		}
	}
	else if (strveq(op2, "/"))
	{
		double a;
		double xr, xi;
		if (reverse)
		{
			for (k = 0; k < x->len; k++)
			{
				if (k < y->len)
				{
					if (x->imag != NULL)
					{
						if (x->data[k] == 0.0 && x->imag[k] == 0.0)
						{
							if (sp_warning)
								fprintf(stderr,
										"warning: dvoper: divide by zero\n");
							if (y->data[k] == 0.0)
							{
								x->data[k] = 0.0;
							}
							else
							{
								x->data[k] = y->data[k] / ALITTLE_NUMBER;
							}
							if (y->imag != NULL)
							{
								if (y->imag[k] == 0.0)
								{
									x->imag[k] = 0.0;
								}
								else
								{
									x->imag[k] = y->imag[k] / ALITTLE_NUMBER;
								}
							}
							else
							{
								x->imag[k] = 0.0;
							}
						}
						else
						{
							a = CSQUARE(x->data[k], x->imag[k]);
							if (y->imag != NULL)
							{
								xr = x->data[k] * y->data[k]
										+ x->imag[k] * y->imag[k];
								xi = x->data[k] * y->imag[k]
										- x->imag[k] * y->data[k];
								x->data[k] = xr / a;
								x->imag[k] = xi / a;
							}
							else
							{
								x->data[k] = x->data[k] * y->data[k] / a;
								x->imag[k] = -x->imag[k] * y->data[k] / a;
							}
						}
					}
					else
					{
						if (x->data[k] != 0.0)
						{
							x->data[k] = y->data[k] / x->data[k];
						}
						else
						{
							if (sp_warning)
								fprintf(stderr,
										"warning: dvoper: divide by zero\n");
							if (y->data[k] == 0.0)
							{
								x->data[k] = 0.0;
							}
							else
							{
								x->data[k] = y->data[k] / ALITTLE_NUMBER;
							}
						}
					}
				}
				else
				{
					x->data[k] = 0.0;
					if (x->imag != NULL)
					{
						x->imag[k] = 0.0;
					}
				}
			}
		}
		else
		{
			for (k = 0; k < x->len; k++)
			{
				if (k < y->len)
				{
					if (x->imag != NULL && y->imag != NULL)
					{
						if (y->data[k] == 0.0 && y->imag[k] == 0.0)
						{
							if (sp_warning)
								fprintf(stderr,
										"warning: dvoper: divide by zero\n");
							if (x->data[k] == 0.0)
							{
								x->data[k] = 0.0;
							}
							else
							{
								x->data[k] = x->data[k] / ALITTLE_NUMBER;
							}
							if (x->imag[k] == 0.0)
							{
								x->imag[k] = 0.0;
							}
							else
							{
								x->imag[k] = x->imag[k] / ALITTLE_NUMBER;
							}
						}
						else
						{
							a = CSQUARE(y->data[k], y->imag[k]);
							xr = x->data[k] * y->data[k]
									+ x->imag[k] * y->imag[k];
							xi = -x->data[k] * y->imag[k]
									+ x->imag[k] * y->data[k];
							x->data[k] = xr / a;
							x->imag[k] = xi / a;
						}
					}
					else
					{
						if (y->data[k] == 0.0)
						{
							if (sp_warning)
								fprintf(stderr,
										"warning: dvoper: divide by zero\n");
							if (x->data[k] == 0.0)
							{
								x->data[k] = 0.0;
							}
							else
							{
								x->data[k] = x->data[k] / ALITTLE_NUMBER;
							}
							if (x->imag != NULL)
							{
								if (x->imag[k] == 0.0)
								{
									x->imag[k] = 0.0;
								}
								else
								{
									x->imag[k] = x->imag[k] / ALITTLE_NUMBER;
								}
							}
						}
						else
						{
							x->data[k] = x->data[k] / y->data[k];
							if (x->imag != NULL)
							{
								x->imag[k] = x->imag[k] / y->data[k];
							}
						}
					}
				}
				else
				{
					x->data[k] = 0.0;
					if (x->imag != NULL)
					{
						x->imag[k] = 0.0;
					}
				}
			}
		}
	}
	else if (strveq(op2, "^"))
	{
		float xr, xi;
		float yr, yi;
		if (reverse)
		{
			if (x->imag != NULL)
			{
				for (k = 0; k < x->len; k++)
				{
					if (k < y->len)
					{
						if (y->imag == NULL)
						{
							yr = y->data[k];
							yi = 0.0;
						}
						else
						{
							yr = y->data[k];
							yi = y->imag[k];
						}
						if (yr == 0.0 && yi == 0.0)
						{
							x->data[k] = 0.0;
							x->imag[k] = 0.0;
						}
						else if (x->imag[k] == 0.0 && yi == 0.0)
						{
							x->data[k] = pow(y->data[k], x->data[k]);
						}
						else
						{
							wtk_syn_clog(&yr, &yi);
							xr = x->data[k] * yr - x->imag[k] * yi;
							xi = x->data[k] * yi + x->imag[k] * yr;
							wtk_syn_cexp(&xr, &xi);
							x->data[k] = xr;
							x->imag[k] = xi;
						}
					}
					else
					{
						x->data[k] = 0.0;
						x->imag[k] = 0.0;
					}
				}
			}
			else
			{
				for (k = 0; k < x->len; k++)
				{
					if (k < y->len)
					{
						x->data[k] = pow(y->data[k], x->data[k]);
					}
					else
					{
						x->data[k] = 0.0;
					}
				}
			}
		}
		else
		{
			if (x->imag != NULL)
			{
				for (k = 0; k < x->len; k++)
				{
					if (k < y->len)
					{
						if (x->data[k] == 0.0 && x->imag[k] == 0.0)
						{
							x->data[k] = 0.0;
							x->imag[k] = 0.0;
						}
						else
						{
							if (y->imag == NULL)
							{
								yr = y->data[k];
								yi = 0.0;
							}
							else
							{
								yr = y->data[k];
								yi = y->imag[k];
							}
							if (x->imag[k] == 0.0 && yi == 0.0)
							{
								x->data[k] = pow(x->data[k], y->data[k]);
							}
							else
							{
								wtk_syn_clog(&x->data[k], &x->imag[k]);
								xr = x->data[k] * yr - x->imag[k] * yi;
								xi = x->data[k] * yi + x->imag[k] * yr;
								wtk_syn_cexp(&xr, &xi);
								x->data[k] = xr;
								x->imag[k] = xi;
							}
						}
					}
					else
					{
						x->data[k] = 1.0;
						x->imag[k] = 1.0;
					}
				}
			}
			else
			{
				for (k = 0; k < x->len; k++)
				{
					if (k < y->len)
					{
						x->data[k] = pow(x->data[k], y->data[k]);
					}
					else
					{
						x->data[k] = 1.0;
					}
				}
			}
		}
	}
	else
	{
		fprintf(stderr, "dvoper: unknouwn operation: %s\n", op2);
		exit(1);
	}
	return;
}

void wtk_syn_vector_dvpaste(wtk_syn_vector_t *y, wtk_syn_vector_t *x,
		long offset, long length, int overlap)
{
	int k;
	int pos;
	register float *f1,*f2,*f3,*f4,*fe;

	if (length <= 0 || length > x->len)
	{
		length = x->len;
	}
	//wtk_debug("overlap=%d len=%ld offset=%ld\n",overlap,length,offset);
	if (overlap)
	{
		k=y->len-offset;
		length=min(k,length);
		if(offset<0)
		{
			pos=0;
			pos=-offset;
		}else
		{
			k = 0;pos=offset;
		}
		if(x->imag && y->imag)
		{
			f1=y->data+pos;
			f2=x->data+k;
			f3=y->imag+pos;
			f4=x->imag+k;
			fe=f2+length;
			while(f2<fe)
			{
				*(f1++)+=*(f2++);
				*(f3++)+=*(f4++);
			}
//			for (; k < length; ++k,++pos)
//			{
//				y->data[pos] += x->data[k];
//				y->imag[pos] += x->imag[k];
//			}
		}else
		{
			f1=y->data+pos;
			f2=x->data+k;
			fe=f2+length;
			while(f2<fe)
			{
				*(f1++)+=*(f2++);
			}
		}
	}
	else
	{
		k=y->len-offset;
		length=min(k,length);
		if(offset<0)
		{
			pos=0;
			pos=-offset;
		}else
		{
			k = 0;pos=offset;
		}
		if(x->imag && y->imag)
		{
			f1=y->data+pos;
			f2=x->data+k;
			f3=y->imag+pos;
			f4=x->imag+k;
			fe=f2+length;
			while(f2<fe)
			{
				*(f1++)=*(f2++);
				*(f3++)=*(f4++);
			}
		}else
		{
			f1=y->data+pos;
			f2=x->data+k;
			fe=f2+length;
			while(f2<fe)
			{
				*(f1++)=*(f2++);
			}
		}
	}
//	exit(0);
}

// smoothing window for group delay
wtk_syn_vector_t* wtk_rphase_xgrpdlywin(wtk_rphase_t *p)
{
	wtk_syn_vector_t *v;
	int fftl2;
	int k;
	float value, sum;

	fftl2 = p->fftl / 2;
	v = wtk_syn_vector_new(p->fftl, 0);
	for (k = 0, sum = 0.0; k < p->fftl; ++k)
	{
		value = p->fs * (k - fftl2) / p->fftl / p->gdbw;
		//wtk_debug("v[%d]=%f\n",k,value);
		// slope difinition function
		v->data[k] = exp(-0.25 * PI * SQUARE(value));
		sum += v->data[k];
	}
	//wtk_debug("sum=%f\n",sum);
	wtk_syn_vector_dvscoper(v, "/", sum);
	return v;
}

// gd window in frequency domain
wtk_syn_vector_t* wtk_rphase_xfgrpdlywin(wtk_rphase_t *p)
{
	wtk_syn_vector_t *x, *y;

	x = wtk_rphase_xgrpdlywin(p);
	wtk_syn_vector_dvfftshift(x);
	y = wtk_syn_vector_xdvfft(x, p->fft);
	wtk_syn_vector_dvifree(y);
	wtk_syn_vector_delete(x);
	//wtk_syn_vector_print(y);
	//exit(0);
	return y;
}

// group delay band width
wtk_syn_vector_t* wtk_rphase_xgdweight(wtk_rphase_t *p, float bw)
{
	wtk_syn_vector_t *x;
	int k;

	x = wtk_syn_vector_new(p->fftl / 2 + 1, 0);
	for (k = 0; k < x->len; ++k)
	{
		x->data[k] = 1.0
				/ (1.0
						+ exp(
								-((double) (k + 1) * p->fs / (double) p->fftl
										- p->cornf) / bw));
	}
	return x;
}

// group delay
void wtk_rphase_getgrpdly(wtk_rphase_t *p)
{
	long k;
	long hfftl = p->fftl / 2 + 1;
	double df = p->fs / (double) p->fftl * 2.0 * PI;
	double value;
	wtk_syn_vector_t *ngd;

	// noise based apf
	ngd = wtk_syn_vector_new(hfftl, 0);
	//wtk_syn_vector_dvrandn(ngd);

	// multiply gd weighting window
	if (p->gdwt)
	{
		wtk_syn_vector_dvoper(ngd, "*", p->gdwt);
	}
	for (k = 0; k < hfftl; ++k)
	{
		p->gd->data[k] = ngd->data[k];
	}
	if (p->fgdsw)
	{
		// convolute gd smoothing window
		wtk_syn_vector_dvfftturn(p->gd);
		wtk_syn_vector_dvfft(p->gd, p->fft);
		wtk_syn_vector_dvoper(p->gd, "*", p->fgdsw);
		wtk_syn_vector_dvifft(p->gd, p->fft);
		wtk_syn_vector_dvifree(p->gd);
	}
	// adjust gd power
	value = sqrt((double) p->fftl * p->gdbw / p->fs);
	value *= p->gdsd * df / 1000.0;
	for (k = 0; k < hfftl; k++)
	{
		p->gd->data[k] *= value;
	}
	// turn data
	wtk_syn_vector_dvfftturn(p->gd);
}

float wtk_syn_rem(float x, float y)
{
	double n, z;

	z = modf(x / y, &n);
	z = x - n * y;

	return z;
}

// noise based apf
void wtk_rphase_gdtorandomapf(wtk_rphase_t *p)
{
	int k;
	float value,tf;
	wtk_syn_vector_t *phs;
	register float *f1,*f2,*f3,*f4;

	// integrate group delay
	value = p->gd->data[0];
	phs = wtk_syn_vector_xdvcumsum(p->gd);
	wtk_syn_vector_dvscoper(phs, "-", value);
	// smoothing phase transition
	value = wtk_syn_rem(phs->data[p->fftl - 1] + phs->data[1],
			2.0 * PI) - 2.0 * PI;
	f1=phs->data;
	f2=p->phstransw->data;
	f3=p->apf->data;
	f4=p->apf->imag;
	for(k=0;k<p->fftl;++k,++f1,++f2,++f3,++f4)
	{
		*f1=tf=-(*f1-*f2 * value);
		*f3=cos(tf);
		*f4=sin(tf);
	}
	return;
}

// group delay
void wtk_rphase_getrandomapf(wtk_rphase_t *p)
{
	wtk_rphase_getgrpdly(p);
	wtk_rphase_gdtorandomapf(p);
}

// spectrum with random phase
void wtk_rphase_randomspec(wtk_rphase_t *p, wtk_syn_vector_t *spc)
{
	if(0)
	{
		wtk_rphase_getrandomapf(p);
		wtk_syn_vector_dvoper(spc, "*", p->apf);
	}else
	{
		wtk_syn_vector_t y;

		y.data=_data;
		y.imag=_imag;
		y.len=sizeof(_data)/sizeof(float);
		wtk_syn_vector_dvoper(spc,"*",&y);
	}
}

wtk_rphase_t* wtk_rphase_new(float sampfreq, long fftlen, wtk_syn_fft_t *fft)
{
	wtk_rphase_t *p;

	p = (wtk_rphase_t*) wtk_malloc(sizeof(wtk_rphase_t));
	p->gdbw = 70.0;
	p->gdsd = 1.0;
	p->cornf = 3500.0;
	p->fs = sampfreq;
	p->fftl = fftlen;
	p->fft = fft;
	p->phstransw = wtk_syn_vector_xphstranswin(fftlen);
	p->fgdsw = wtk_rphase_xfgrpdlywin(p);
	p->gdwt = wtk_rphase_xgdweight(p, 300.0);
	p->gd = wtk_syn_vector_new(fftlen, 0);
	p->apf = wtk_syn_vector_new(fftlen, 0);
	wtk_syn_vector_dvialloc(p->apf, 0);
	return p;
}

void wtk_rphase_delete(wtk_rphase_t *p)
{
	wtk_syn_vector_delete(p->phstransw);
	wtk_syn_vector_delete(p->fgdsw);
	wtk_syn_vector_delete(p->gdwt);
	wtk_syn_vector_delete(p->gd);
	wtk_syn_vector_delete(p->apf);
	wtk_free(p);
}

wtk_syn_sigp_t* wtk_syn_sigp_new(wtk_syn_cfg_t *cfg, int order)
{
	wtk_syn_sigp_t *p;
	wtk_syn_hmm_cfg_t *hmm_cfg = &(cfg->hmm_cfg);
	int len;

	len = hmm_cfg->fftlen;
	p = (wtk_syn_sigp_t*) wtk_malloc(sizeof(wtk_syn_sigp_t));
	p->cfg = cfg;
	p->len = hmm_cfg->fftlen;
	p->fft = wtk_syn_fft_new(p->len);
	p->hlen = (hmm_cfg->fftlen - 1) / 2;
	p->f0min = 70.0;
	p->uvf0 = 500.0 / (hmm_cfg->fperiod * 1000.0 / hmm_cfg->rate);
	p->hann = wtk_syn_vector_new(len, 0);
	p->psres = wtk_syn_vector_new(len, 0);
	p->pulse = wtk_syn_vector_new(len, 0);
	p->noise = wtk_syn_vector_new(len, 0);
	p->vs = wtk_syn_vocoder_new(hmm_cfg, order);
	p->volume_scale=1.0;
	//wtk_debug("flag=%d\n",hmm_cfg->use_rnd_flag);
	if (hmm_cfg->use_rnd_flag)
	{
		p->rphase = wtk_rphase_new(hmm_cfg->rate, hmm_cfg->fftlen, (p->fft));
	}
	else
	{
		p->rphase = NULL;
	}
	return p;
}

int wtk_syn_sigp_bytes(wtk_syn_sigp_t* p)
{
	int bytes;

	bytes=p->len*sizeof(wtk_syn_vector_t);
	bytes+=p->len*sizeof(wtk_syn_vector_t);
	bytes+=p->len*sizeof(wtk_syn_vector_t);
	bytes+=p->len*sizeof(wtk_syn_vector_t);
	bytes+=wtk_syn_fft_bytes(p->fft);
	bytes+=wtk_syn_vocoder_bytes(p->vs);

	return bytes;
}

void wtk_syn_sigp_delete(wtk_syn_sigp_t *p)
{
	wtk_syn_fft_delete(p->fft);
	wtk_syn_vector_delete(p->hann);
	wtk_syn_vector_delete(p->psres);
	wtk_syn_vector_delete(p->pulse);
	wtk_syn_vector_delete(p->noise);
	wtk_syn_vocoder_delete(p->vs);
	if(p->rphase)
	{
		wtk_rphase_delete(p->rphase);
	}
	wtk_free(p);
}

void wtk_syn_sigp_reset(wtk_syn_sigp_t *p)
{
}


void wtk_syn_sigp_set_volume_scale(wtk_syn_sigp_t *p,float scale)
{
	p->volume_scale=scale;
}

float wtk_syn_spround(float x)
{
	float y;

	y = floor(x + 0.5);
	return y;
}

void wtk_syn_hanning(float *window, int len, int sidx, int eidx)
{
	int k;
	float a;

	//wtk_debug("sidx=%d eidx=%d len=%d\n",sidx,eidx,len);
	if (len <= 1)
	{
		return;
	}
	a = 2.0 * PI / (len + 1);
	for (k = sidx; k < eidx; ++k)
	{
		window[k] = 0.5 - 0.5 * cos(a * (k + 1));
		//wtk_debug("v[%d]=%f\n",k,window[k]);
	}
	//exit(0);
}

void wtk_syn_hanning2(float *window, int len)
{
	int k;
	float a;

	if (len <= 1)
	{
		return;
	}
	a = 2.0 * PI / (len + 1);
	for (k = 0; k < len; ++k)
	{
		window[k] = 0.5 - 0.5 * cos(a * (k + 1));
		//wtk_debug("v[%d]=%f\n",k,window[k]);
	}
}

void wtk_syn_sigp_pshannwin(wtk_syn_sigp_t *p, int pt0p, int t0p)
{
	int  wlen;

//	for (k = 0; k < p->len; ++k)
//	{
//		p->hann->data[k] = 0.0;
//	}
	memset(p->hann->data,0,p->len*sizeof(float));
	wlen = pt0p + t0p + 1;
	//wtk_debug("wlen=%d/%d\n",wlen,p->cfg->hmm_cfg.fftlen);
	if (wlen > p->len)
	{
		t0p = p->hlen;
		wlen = p->len;
		wtk_syn_hanning2(&(p->hann->data[p->hlen - t0p]), wlen);
	}
	else
	{
		wtk_syn_hanning(&(p->hann->data[p->hlen - pt0p]), pt0p * 2 + 1, 0,
				pt0p);
		wtk_syn_hanning(&(p->hann->data[p->hlen - t0p]), t0p * 2 + 1, t0p,
				t0p * 2 + 1);
	}
	//exit(0);
}

//pitch-synchronous excitation
void wtk_syn_sigp_psres_mix_rndphs(wtk_syn_sigp_t *p, wtk_matrix_t *bndap,
		int t, float sigp)
{
	long k, b, bs, be;
	double wnz, wpr;
	int col, row;

	if (p->len != p->psres->len)
	{
		wtk_debug("len not equal=%d/%d\n", p->len, p->psres->len);
		exit(0);
	}
	p->len = p->psres->len;
	if (bndap || p->cfg->hmm_cfg.use_rnd_flag)
	{
		wtk_syn_vector_dvfft(p->pulse, (p->fft));
		if (bndap)
		{
			col = wtk_matrix_cols(bndap);
			row = wtk_matrix_rows(bndap);
			wtk_syn_vector_dvfft(p->noise, (p->fft));
			for (b = 0; b < col && b < row; ++b)
			{
				// frequency bands
				if (b == 0)
				{
					bs = 0;
					be = p->len / 16;
				}
				else if (b == 1)
				{
					bs = p->len / 16;
					be = p->len / 8;
				}
				else if (b == 2)
				{
					bs = p->len / 8;
					be = p->len / 4;
				}
				else if (b == 3)
				{
					bs = p->len / 4;
					be = p->len * 3 / 8;
				}
				else
				{
					bs = p->len * 3 / 8;
					be = p->len / 2 + 1;
				}
				// weighting for mixed excitation
				if (sigp <= 0.0)
				{
					wnz = SYN_MIN(1.0, pow(10.0, (bndap[t+1][b+1]) / 20.0));
				}
				else
				{
					wnz = wtk_syn_sigmoid(
							pow(10.0, (bndap[t + 1][b + 1]) / 20.0), sigp,
							0.25);
					wnz = SYN_MIN(1.0, wnz);
				}
				wpr = sqrt(SYN_MAX(0.0, 1.0 - SQUARE(wnz)));
				for (k = bs; k < be; k++)
				{
					p->noise->data[k] *= wnz;
					p->noise->imag[k] *= wnz;
					p->pulse->data[k] *= wpr;
					p->pulse->imag[k] *= wpr;
					if (k != 0 && k != p->len / 2)
					{
						p->noise->data[p->len - k] *= wnz;
						p->noise->imag[p->len - k] *= wnz;
						p->pulse->data[p->len - k] *= wpr;
						p->pulse->imag[p->len - k] *= wpr;
					}
				}
			}
			wtk_syn_vector_dvfft(p->noise, (p->fft));
			wtk_syn_vector_dvifree(p->noise);
		}
		//		// random phase
		if (p->cfg->hmm_cfg.use_rnd_flag)
		{
			wtk_rphase_randomspec(p->rphase, p->pulse);
		}
		wtk_syn_vector_dvifft(p->pulse, (p->fft));
		wtk_syn_vector_dvifree(p->pulse);
	}
	// mixed excitation
	if (bndap)
	{
		for (k = 0; k < p->len; ++k)
		{
			p->psres->data[k] = p->pulse->data[k] + p->noise->data[k];
		}
	}
	else
	{
		for (k = 0; k < p->len; ++k)
		{
			p->psres->data[k] = p->pulse->data[k];
		}
	}
	return;
}

/* *
 * remedy for fit wtk_syn_sigp_psres_mix_rndphs
 * add by dmd 2018.02.22
 * */
void wtk_syn_sigp_psres_mix_rndphs_u(wtk_syn_sigp_t *p, wtk_matf_t *bndap,
		int t, float sigp)
{
	long k, b, bs, be;
	double wnz, wpr;
	int col, row;

	if (p->len != p->psres->len)
	{
		wtk_debug("len not equal=%d/%d\n", p->len, p->psres->len);
		exit(0);
	}
	p->len = p->psres->len;
	//printf("use_rnd_flag=%d\n",p->cfg->hmm_cfg.use_rnd_flag);
	if (bndap || p->cfg->hmm_cfg.use_rnd_flag)
	{
		wtk_syn_vector_dvfft(p->pulse, (p->fft));
		if (bndap)
		{
			col = bndap->col;
			row = bndap->row;
			wtk_syn_vector_dvfft(p->noise, (p->fft));
			//for (b = 0; b < col && b < row; ++b)
			for (b = 0; b < col && t < row; ++b)   //above maybe error ,here remedy by dmd 2018.02.22
			{
				// frequency bands
				if (b == 0)
				{
					bs = 0;
					be = p->len / 16;
				}
				else if (b == 1)
				{
					bs = p->len / 16;
					be = p->len / 8;
				}
				else if (b == 2)
				{
					bs = p->len / 8;
					be = p->len / 4;
				}
				else if (b == 3)
				{
					bs = p->len / 4;
					be = p->len * 3 / 8;
				}
				else
				{
					bs = p->len * 3 / 8;
					be = p->len / 2 + 1;
				}
				// weighting for mixed excitation
				//printf("bd[%d][%ld]=%.5f\n",t,b,bndap->p[t*col+b]);
				if (sigp <= 0.0)
				{
					//wnz = SYN_MIN(1.0, pow(10.0, (bndap[t+1][b+1]) / 20.0));
					wnz = SYN_MIN(1.0, pow(10.0, (bndap->p[t*col+b]) / 20.0));
				}
				else
				{
					//wnz = wtk_syn_sigmoid(
					//		pow(10.0, (bndap[t+1][b+1])]) / 20.0), sigp,
					//		0.25);
					wnz = wtk_syn_sigmoid(
							pow(10.0, (bndap->p[t*col+b]) / 20.0), sigp,
							0.25);
					wnz = SYN_MIN(1.0, wnz);
				}
				wpr = sqrt(SYN_MAX(0.0, 1.0 - SQUARE(wnz)));
				for (k = bs; k < be; k++)
				{
					p->noise->data[k] *= wnz;
					p->noise->imag[k] *= wnz;
					p->pulse->data[k] *= wpr;
					p->pulse->imag[k] *= wpr;
					if (k != 0 && k != p->len / 2)
					{
						p->noise->data[p->len - k] *= wnz;
						p->noise->imag[p->len - k] *= wnz;
						p->pulse->data[p->len - k] *= wpr;
						p->pulse->imag[p->len - k] *= wpr;
					}
				}
			}
			/*
			 * following remedy by dm at 2018.02.24
			 * raw: bug, error for bag feat.
			 * remedy: right method
			*/
			//wtk_syn_vector_dvfft(p->noise, (p->fft)); //raw
			wtk_syn_vector_dvifft(p->noise, (p->fft));  //remedy

			wtk_syn_vector_dvifree(p->noise);
		}
		//		// random phase
		if (p->cfg->hmm_cfg.use_rnd_flag)
		{
			wtk_rphase_randomspec(p->rphase, p->pulse);
		}
		wtk_syn_vector_dvifft(p->pulse, (p->fft));
		wtk_syn_vector_dvifree(p->pulse);
	}
	// mixed excitation
	if (bndap)
	{
		for (k = 0; k < p->len; ++k)
		{
			p->psres->data[k] = p->pulse->data[k] + p->noise->data[k];
			//printf("vdg[%ld]=%f %f %f\n", k, p->psres->data[k],p->pulse->data[k],p->noise->data[k]);
		}
	}
	else
	{
		for (k = 0; k < p->len; ++k)
		{
			p->psres->data[k] = p->pulse->data[k];
		}
	}
	return;
}

void wtk_syn_init_pulse(wtk_syn_vector_t *pulse,float fagin)
{
	register float *f,*fe,*f2,*f3,*f4;

	if (!pulse->imag)
	{
		wtk_syn_vector_dvialloc(pulse, 0);
	}
	f=pulse->data;
	fe=f+pulse->len;
	f2=data;
	f3=pulse->imag;
	f4=imag;
	while(f<fe)
	{
		*(f++)=*(f2++)*fagin;
		*(f3++)=*(f4++)*fagin;
	}
}

//pitch-synchronous excitation
void wtk_syn_sigp_psres_mix_rndphs2(wtk_syn_sigp_t *p, wtk_matf_t *bndap,
		int t, float sigp,float fagin)
{
	long k, b, bs, be;
	double wnz, wpr;
	float f;
	int col, row;

//	if (p->len != p->psres->len)
//	{
//		wtk_debug("len not equal=%d/%d\n", p->len, p->psres->len);
//		exit(0);
//	}
	p->len = p->psres->len;
	if (bndap || p->cfg->hmm_cfg.use_rnd_flag)
	{
		wtk_syn_init_pulse(p->pulse,fagin);
		//exit(0);
		//wtk_syn_vector_dvfft(p->pulse, (p->fft));
		if (bndap)
		{
			col = bndap->col;//wtk_matrix_cols(bndap);
			row = bndap->row;//wtk_matrix_rows(bndap);
			wtk_syn_vector_dvfft(p->noise, (p->fft));
			for (b = 0; b < col && b < row; ++b)
			{
				// frequency bands
				if (b == 0)
				{
					bs = 0;
					be = p->len / 16;
				}
				else if (b == 1)
				{
					bs = p->len / 16;
					be = p->len / 8;
				}
				else if (b == 2)
				{
					bs = p->len / 8;
					be = p->len / 4;
				}
				else if (b == 3)
				{
					bs = p->len / 4;
					be = p->len * 3 / 8;
				}
				else
				{
					bs = p->len * 3 / 8;
					be = p->len / 2 + 1;
				}
				//f=bndap[t+1][b+1];
				f=bndap->p[t*col+b];
				// weighting for mixed excitation
				if (sigp <= 0.0)
				{
					wnz = SYN_MIN(1.0, pow(10.0, (f) / 20.0));
				}
				else
				{
					wnz = wtk_syn_sigmoid(
							pow(10.0, f/ 20.0), sigp,
							0.25);
					wnz = SYN_MIN(1.0, wnz);
				}
				wpr = sqrt(SYN_MAX(0.0, 1.0 - SQUARE(wnz)));
				for (k = bs; k < be; k++)
				{
					p->noise->data[k] *= wnz;
					p->noise->imag[k] *= wnz;
					p->pulse->data[k] *= wpr;
					p->pulse->imag[k] *= wpr;
					if (k != 0 && k != p->len / 2)
					{
						p->noise->data[p->len - k] *= wnz;
						p->noise->imag[p->len - k] *= wnz;
						p->pulse->data[p->len - k] *= wpr;
						p->pulse->imag[p->len - k] *= wpr;
					}
				}
			}
			/*
			 * following remedy by dm at 2018.02.24
			 * raw: bug, error for bag feat.
			 * remedy: right method
			*/
			//wtk_syn_vector_dvfft(p->noise, (p->fft)); //raw
			wtk_syn_vector_dvifft(p->noise, (p->fft));  //remedy

			wtk_syn_vector_dvifree(p->noise);
		}
		//		// random phase
		if (p->cfg->hmm_cfg.use_rnd_flag)
		{
			wtk_rphase_randomspec(p->rphase, p->pulse);
		}
		wtk_syn_vector_dvifft(p->pulse, (p->fft));
		wtk_syn_vector_dvifree(p->pulse);
	}
	// mixed excitation
	if (bndap)
	{
		for (k = 0; k < p->len; ++k)
		{
			p->psres->data[k] = p->pulse->data[k] + p->noise->data[k];
		}
	}
	else
	{
		for (k = 0; k < p->len; ++k)
		{
			p->psres->data[k] = p->pulse->data[k];
		}
	}
	return;
}

float wtk_syn_vector_max(wtk_syn_vector_t *v)
{
	long k;
	double max;

	max = v->data[0];
	for (k = 1; k < v->len; k++)
	{
		if (max < v->data[k])
		{
			max = v->data[k];
		}
	}
	return max;
}

float wtk_syn_vector_min(wtk_syn_vector_t *v)
{
	long k;
	double min;

	min = v->data[0];
	for (k = 1; k < v->len; k++)
	{
		if (min > v->data[k])
		{
			min = v->data[k];
		}
	}
	return min;
}

void wtk_syn_vector_waveampcheck(wtk_syn_vector_t *wav)
{
	float f1, f2;

	f1 = wtk_syn_vector_max(wav);
	f2 = wtk_syn_vector_min(wav);
	//wtk_debug("f1=%f/%f\n",f1,f2);
	f1 = fabs(f1);
	f2 = fabs(f2);
	f1 = max(f1,f2);
	if (f1 >= 32000.0)
	{
		wtk_syn_vector_dvscoper(wav, "*", 32000.0 / f1);
	}
}

#include "wtk/core/wavehdr.h"

void wtk_syn_vector_dump_wav(wtk_syn_vector_t *v)
{
	short *data;
	int i;

	data = (short*) wtk_malloc(v->len*sizeof(short));
	for (i = 0; i < v->len; ++i)
	{
		data[i] = v->data[i];
	}
	wtk_debug("save testx.wav\n");
	wave_write_file("testx.wav", 16000, (char*) data, v->len * sizeof(short));
	wtk_free(data);
	//exit(0);
}

void wtk_syn_sigp_dump_wav(wtk_syn_sigp_t *p,wtk_syn_vector_t *v)
{
#define SHORT_LIMITED(x) (x>32767 ? 32767 : (x<-32768 ? -32768 : x))
	float *fp;
	short *data;
	int i,t;

	if(v->len<=0)
	{
		return;
	}
	//wtk_debug("len=%d ms=%f\n",v->len,v->len*1000.0/16000);
	data = (short*) wtk_malloc(v->len*sizeof(short));
	fp=v->data;
	if(p->volume_scale!=1.0)
	{
		for (i = 0; i < v->len; ++i)
		{
			t=fp[i]*p->volume_scale;
			data[i] =SHORT_LIMITED(t);
		}
	}else
	{
		for (i = 0; i < v->len; ++i)
		{
			data[i]=fp[i];
		}
	}
	//wtk_debug("avg=%f\n",t*1.0/v->len);
	p->notify(p->notify_ths,(char*)data,v->len<<1);
	wtk_free(data);
	//exit(0);
}

void wtk_syn_sigp_process(wtk_syn_sigp_t *p,wtk_syn_vector_t *f0v,
		wtk_matf_t *mcep,wtk_matf_t *bndap,float sigp)
{
	wtk_syn_hmm_cfg_t *cfg = &(p->cfg->hmm_cfg);
	wtk_syn_vector_t *xd, *syn,*ntbl;
	int row;
	int k, t, pt, t0p, pt0p, pos, tidx;
	float f0, t0, time;
	float t01;


//	wtk_syn_vector_print(f0v);
//	wtk_matf_print(mcep);
	//wtk_matf_print(bndap);
	//exit(0);

	t01= cfg->rate * 1.0 / p->uvf0;
	row = mcep->row;
	xd = wtk_syn_vector_new(row * (cfg->fperiod + 2) + p->len, 0.0);
	ntbl=wtk_syn_vector_new(xd->len,0.0);
	wtk_syn_vector_dvrandn(ntbl);
	//wtk_syn_vector_print(ntbl);

	pt = -1;
	pt0p = 0;
	for (t = 0, pos = 0, tidx = 0, time = 0.0; t < row;)
	{
		f0 = t >= f0v->len ? 0.0 : f0v->data[t];
		tidx = (long) wtk_syn_spround(time);
		//wtk_debug("tidx=%d time=%f\n",tidx,time);
		if (f0 > 0.0)
		{
			if (f0 < p->f0min)
			{
				f0 = p->f0min;
			}
			t0 = cfg->rate * 1.0 / f0;
			t0p = (long) wtk_syn_spround(t0);
			for (k = 0; k < p->len; ++k)
			{
				p->pulse->data[k] = 0;
				p->noise->data[k] = 0;
			}
			// asymmetric pitch-synchronous hanning window
			wtk_syn_sigp_pshannwin(p, pt0p, t0p);
			// normalized pulse
			p->pulse->data[p->hlen] = sqrt(t0);
			// normalized noise
//			memset(p->noise->data + p->hlen - t0p, 0,
//					(t0p * 2 + 1) * sizeof(float));
			for(k=0;k<t0p*2+1;++k)
			{
				p->noise->data[p->hlen-t0p+k]=ntbl->data[p->hlen-t0p+k+tidx];
			}
			// mixed excitation
			//wtk_syn_sigp_psres_mix_rndphs(p, bndap, t, sigp);
			/*
			 *
			 * wtk_syn_sigp_psres_mix_rndphs_u: remedy for fit wtk_syn_sigp_psres_mix_rndphs by dmd 2018.02.22
			 * wtk_syn_sigp_psres_mix_rndphs_u and wtk_syn_sigp_psres_mix_rndphs2 same effect(but diff in values) in current.
			 */
			wtk_syn_sigp_psres_mix_rndphs2(p, bndap, t, sigp,sqrt(t0));
			//wtk_syn_sigp_psres_mix_rndphs_u(p, bndap, t, sigp);
		}
		else
		{
			t0 =t01;
			t0p = (long) wtk_syn_spround(t0);
			wtk_syn_sigp_pshannwin(p, pt0p, t0p);
//			memset(p->psres->data + p->hlen - t0p, 0,
//					(t0p * 2 + 1) * sizeof(float));
			for(k=0;k<t0p*2+1;++k)
			{
				p->psres->data[p->hlen-t0p+k]=ntbl->data[p->hlen-t0p+k+tidx];
				//wtk_debug("v[%ld]=%f\n",p->hlen-t0p+k,p->psres->data[p->hlen-t0p+k]);
			}
//			printf("vd[%d]=%f\n", p->hlen - t0p + k, p->psres->data[p->hlen - t0p + k]);
		}
		pt0p = t0p;
		// multiply window
		wtk_syn_vector_dvoper(p->psres, "*", p->hann);
		// constructing excitation with OLA
		wtk_syn_vector_dvpaste(xd, p->psres, tidx, p->psres->len, 1);
		if (t > pt)
		{
			for (; pt < t; ++pt)
			{
				//wtk_debug("pt=%ld\n",pt);
				wtk_syn_vocoder_mlsafilter(p->vs,
						&(xd->data[pt * cfg->fperiod + p->hlen]),
						mcep->p+((pt+1)*mcep->col),
						cfg->fperiod);
//				wtk_syn_vocoder_mlsafilter(p->vs,
//						&(xd->data[pt * cfg->fperiod + p->hlen]),
//						mcep->p((pt+1)*mcep->col),
//						mcep[pt + 2] + 1, cfg->fperiod);
			}
		}
		if ((pos = tidx + p->psres->len) > xd->len)
		{
			pos = xd->len;
			break;
		}
		time += t0;
		tidx = (long) wtk_syn_spround(time);
		while (tidx > (t + 1) * cfg->fperiod)
		{
			++t;
		}
		//wtk_debug("pos=%d t=%d t0=%f time=%f tidx=%d p->psres->len=%d\n",pos,t,t0,time,tidx,p->psres->len);
	}
	//wtk_debug("pos=%d pt=%d p=%d h=%d\n",pos,pt,cfg->fperiod ,p->hlen);
	//exit(0);
//	wtk_syn_vocoder_mlsafilter(p->vs, &(xd->data[pt * cfg->fperiod + p->hlen]),
//			mcep[pt + 1], pos - (pt * cfg->fperiod + p->hlen));

	wtk_syn_vocoder_mlsafilter(p->vs, &(xd->data[pt * cfg->fperiod + p->hlen]),
			mcep->p+(pt*mcep->col),
			 pos - (pt * cfg->fperiod + p->hlen));

	//xd->len=5000;
	//wtk_syn_vector_print(xd);
	//exit(0);
	//wtk_debug("pos=%d p->hlen=%d %d\n",pos,p->hlen,pos-p->hlen);
	syn = wtk_syn_vector_xdvcut(xd, p->hlen, pos - p->hlen);

	//wtk_syn_vector_print(xd);

	wtk_syn_vector_waveampcheck(syn);

	//wtk_syn_vector_dump_wav(syn);
	wtk_syn_sigp_dump_wav(p,syn);

	wtk_syn_vector_delete(syn);
	wtk_syn_vector_delete(xd);
	wtk_syn_vector_delete(ntbl);
	//exit(0);
}



